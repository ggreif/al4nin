import "/home/ggreif/%NoBackup%/omega/src/LangPrelude.prg"


testIO = do
				 handleIO (return "normal") worker
    where monad ioM
          worker xs = do
											putStr ("HEHE " ++ xs)
											return "inside"


kind TypConstr = Regular | Univ Tag

kind T = TInt | TArr T T | TList T

data Typ :: TypConstr ~> T ~> *0 where
  Int :: Typ Regular TInt
  Var :: Label name -> Typ (Univ name) any
  Arr :: Typ a contra -> Typ b co -> Typ Regular (TArr contra co)
  List :: Typ a t -> Typ Regular (TList t)


data Discharge :: Row Tag Nat ~> Row Tag Nat ~> *0 where
  Triv :: Typ Regular a -> Typ Regular a -> Discharge dict dict
  Deep :: Typ Regular a -> Typ Regular b -> Discharge dict dict
  Alias :: Typ (Univ l) a -> Typ (Univ r) a -> Discharge dict {l=1t, r=1t; dict}r
  Subst :: Typ (Univ l) a -> Typ Regular a -> Discharge dict {l=1t; dict}r


data Thrist :: forall (l :: *1) . (l ~> l ~> *)  ~> l ~> l ~> * where
  Nil :: Thrist k a a
  Cons :: k a b -> Thrist k b c -> Thrist k a c
 deriving List(t)

aV = Var `a
idT = Arr aV aV

bV = Var `b
cV = Var `c
{- no workee :-(
mapT = Arr (Arr bV cV) (Arr (List bV) (List cV))
(Arr mapT1 mapT2) = mapT
(Arr mapT21 mapT22) = mapT2
-}
mapT1 = Arr bV cV
mapT21 = List bV
mapT22 = List cV
mapT2 = Arr mapT21 mapT22
mapT = Arr mapT1 mapT2


intL = List Int

resultV = Var `result

-- gathering constraints for
--   result = map id [1, 2, 4]

{-

1) map id ---> (Arr bV cV) =!= idT == Arr aV aV
2) (map id) [1, 2, 4] ---> List cV =!= List Int
3) result ---> resultV =!= List cV

-}

c1 = Deep mapT1 idT
c2 = Deep mapT21 intL
c3 = Subst resultV mapT22

t1 = [c1, c2, c3]t


mergeTags :: Tag ~> Tag ~> Tag
{mergeTags a a} = a

tryMergeLabels :: Label a -> Label b -> (Label a + Label {mergeTags a b})
tryMergeLabels a b = case labelEq a b of
                     Just eq -> L a
                     Nothing -> R undefined

