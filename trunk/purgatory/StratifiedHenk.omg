-- -*-Haskell-*-

{-
 * Copyright (c) 2006, 2007 Gabor Greif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 -}

-- Usage:
--
--  Set up the environment
--     setenv LD_LIBRARY_PATH /opt/exp/gnu/lib:$LD_LIBRARY_PATH
--     setenv PATH /home/ggreif/%NoBackup%/Omega1.4:$PATH
--
--  Start the omega interpreter by typing
--     omega StratifiedHenk.omg
--  and run your commands on the prompt
--

import "LangPrelude.prg" 
  (head,tail,lookup,member,fst,snd,map,Monad,maybeM,id,ioM,Row,HasType,RCons,RNil,Eq,Equal)

-- \(x:T).x : Pi (x:T) T

-- cit: Kamareddine jfp6
-- Higher Degrees:
-- tau(Gam, lam[i+1]x:A.B) === lam[i]x:A.tau(Gam\x:A, B) forall i of N
--  where lam[0]x:A.B === B
-- lam[1] == Pi, lam[2] == lambda
-- Specialize (i=1):
--  tau(Gam, lambda x:A.B) === Pi x:A.tau(Gam\x:A, B)
-- Specialize (A=int, B=42):
--  tau(Gam, lambda x:Int.42) === Pi x:Int.tau(Gam\x:Int, 42)
--  with tau(Gam, 42) === Int
--  gets: tau(Gam, lambda x:Int.42) === Pi x:Int.Int  (aka. Int->Int)

-- Specialize (i=0, A=Int, B=Int):
-- tau(Gam, Pi x:Int.Int) === lam[0]x:Int.tau(Gam\x:Int, Int)
-- with tau(Gam, Int) === *0
-- tau(Gam, Pi x:Int.Int) === lam[0]x:Int.*0
-- with lam[0]x:Int.*0 === *0
-- tau(Gam, Pi x:Int.Int) === *0

kind Stratum :: *1 where
  Ground :: Stratum -- Regular
  Up :: Stratum ~> Stratum -- Regular
  Push :: Stratum ~> Stratum ~> Stratum -- Admin
--  Push :: Stratum Regular ~> Stratum x ~> Stratum Admin
-- deriving Nat(s)

collapsePi :: Nat ~> Stratum ~> Stratum
--{ collapsePi x y } = x
{ collapsePi Z (Push (Up x) y) } = Ground
{ collapsePi Z (Up x) } = (Up x)
{ collapsePi Z Ground } = Ground
{ collapsePi (S n) x } = x


arr2stratum :: * ~> Stratum
{ arr2stratum (a -> b) } = Push (Up Ground) { arr2stratum b }
{ arr2stratum Int } = Ground
{ arr2stratum Bool } = Ground
{ arr2stratum () } = Ground
{ arr2stratum Float } = Ground
{ arr2stratum (a, b) } = Ground

prop Tractable :: * ~> * where
  IntTractable :: Tractable Int
  PairTractable :: Tractable a -> Tractable b -> Tractable (a, b)
  ArrTractable :: Tractable a -> Tractable b -> Tractable (a -> b)

tract2stratum :: * ~> Stratum
{ tract2stratum (Tractable (a -> b)) } = Push (Up Ground) { tract2stratum (Tractable b) }
{ tract2stratum (Tractable Int) } = Ground
{ tract2stratum (Tractable (a, b)) } = Ground

stratDiff :: Stratum ~> Stratum ~> Nat
{ stratDiff Ground Ground } = #0
{ stratDiff (Up x) (Up y)} = { stratDiff x y }
{ stratDiff (Up x) Ground } = S { stratDiff x Ground }
{ stratDiff (Push x y) z } = { stratDiff x z }

-- --------- From       To
data Henk :: Stratum ~> Stratum ~> *0 where
  Lit :: Tractable a -> a -> Henk { tract2stratum (Tractable a) } Ground
  Bind :: Nat' { stratDiff (Up strat) to } -> Label l -> Henk Ground (Up strat) -> Henk from to -> Henk (Push (Up strat) from) to
--  Func :: (a->b) -> Henk (Up Ground) Ground -- use Lit and {arr2stratum + cleaner}
--  Ref :: Label l -> Henk Ground strat
--  Type :: Tractable a -> Henk { tract2stratum (Tractable a) } (Up Ground)
  Type :: Tractable a -> Henk Ground (Up Ground)
  Star :: Henk Ground (Up (Up g))
  -- Application
  App :: Henk (Push (Up s) from) u -> Henk Ground s -> Henk from u


--a :: Henk Ground Ground
--a = Ref `a

--canon :: Henk strat to -> Henk { collapse strat } to
--canon (Bind l (q@Type) (r@Type)) = Type

guess :: Tractable a -> a
guess IntTractable = 42

tau :: Henk strat to -> Henk { collapsePi { stratDiff strat to } strat } (Up to)
--tau (Bind l q r) = Bind l q (lazy tau r)
--tau (Bind l (q@(Lit _)) (r@(Lit _))) = tau r
--tau (Bind l (q@Type) (r@Type)) = Type
--tau (Bind l q r) = Bind l q (tau r)
--tau (a@Lit) = tau (Bind `ignore a a)
--tau (Lit (ArrTractable a (b@(ArrTractable c d)) f) = Bind `woot (tau (Lit b (f (guess a))))
--tau (Lit (ArrTractable IntTractable IntTractable) f) = Bind `woot (Lit IntTractable 3) (tau (Lit IntTractable (f 42)))
--tau (Lit (ArrTractable IntTractable IntTractable) f) = Bind `woot (Lit IntTractable 3) (tau (Lit IntTractable (f 42)))
--tau (Lit (ArrTractable a b) f) = Bind `woot (tau (Lit b (f (guess a))))
--tau (Lit t _) = Type t

prop Stratum' :: Stratum ~> *0 where
  Ground :: Stratum' Ground
  Up :: forall (a :: Stratum) . Stratum' a -> Stratum' (Up a)
  Push :: forall (a :: Stratum) (b :: Stratum) . Stratum' a -> Stratum' b -> Stratum' (Push a b)




--sameStrat1 :: forall (a :: Stratum) (b :: Stratum) . Stratum' a -> Stratum' b -> Equal { stratDiff (Up a) (Up b) } #0 -> Equal a b


sameStrat1 :: forall (a :: Stratum) (b :: Stratum) . Stratum' a -> Stratum' b -> Equal { stratDiff a b } #0 -> Equal a b
sameStrat1 Ground Ground Eq = Eq
--sameStrat1 (Up x) (Up y) Eq = check (sameStrat1 x y Eq)
-- where theorem hyp = sameStrat1 x y

--sameStrat :: forall (a :: Stratum) (b :: Stratum) . Equal a b -> Equal { stratDiff a b } #0
--sameStrat Eq = check Eq

sameStrat0 :: Stratum' a -> Equal { stratDiff a Ground } #0 -> Equal a Ground
sameStrat0 Ground Eq = Eq
sameStrat0 (Up g) Eq = unreachable

sameStrat2 :: forall (a :: Stratum) (b :: Stratum) . Stratum' a -> Stratum' b -> Equal { stratDiff (Up a) b } #0 -> Equal b (Up a)
sameStrat2 Ground Ground Eq = unreachable
sameStrat2 Ground (Up Ground) Eq = Eq
--sameStrat2 Ground (Up (Up b)) Eq = unreachable
--sameStrat2 (Up a) Ground Eq = unreachable
--sameStrat2 a (Up a) (Up Ground) = Eq


--sameStratUp :: Stratum' a -> Equal { stratDiff a  } #0 -> Equal a a


tau (Bind Z l q r) = check Star
 where theorem sameStrat0, sameStrat2


{-
:set solving
:set predicate_emission
:set narrowing
:set theorem
:set
-}

-----###tau (Type _) = Star
-----###tau Star = Star

kind HasHenk :: *1 where {}

{-
--eval :: Row HasHenk -> Henk st s -> Henk st s
eval :: Int -> Henk st s -> Henk st s
eval _ (App (Bind l q r) inp) = r
eval _ other = other
-}
