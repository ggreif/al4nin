-- -*-Haskell-*-

{-
 * Copyright (c) 2006, 2007 Gabor Greif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 -}

-- Usage:
--
--  Set up the environment
--     setenv LD_LIBRARY_PATH /opt/exp/gnu/lib:$LD_LIBRARY_PATH
--     setenv PATH /home/ggreif/%NoBackup%/Omega1.4:$PATH
--
--  Start the omega interpreter by typing
--     omega StratifiedHenk.omg
--  and run your commands on the prompt
--

import "LangPrelude.prg" 
  (head,tail,lookup,member,fst,snd,map,Monad,maybeM,id,ioM,Row,HasType,RCons,RNil,Eq,Equal)

-- \(x:T).x : Pi (x:T) T

-- cit: Kamareddine jfp6
-- Higher Degrees:
-- tau(Gam, lam[i+1]x:A.B) === lam[i]x:A.tau(Gam\x:A, B) forall i of N
--  where lam[0]x:A.B === B
-- lam[1] == Pi, lam[2] == lambda
-- Specialize (i=1):
--  tau(Gam, lambda x:A.B) === Pi x:A.tau(Gam\x:A, B)
-- Specialize (A=int, B=42):
--  tau(Gam, lambda x:Int.42) === Pi x:Int.tau(Gam\x:Int, 42)
--  with tau(Gam, 42) === Int
--  gets: tau(Gam, lambda x:Int.42) === Pi x:Int.Int  (aka. Int->Int)

-- Specialize (i=0, A=Int, B=Int):
-- tau(Gam, Pi x:Int.Int) === lam[0]x:Int.tau(Gam\x:Int, Int)
-- with tau(Gam, Int) === *0
-- tau(Gam, Pi x:Int.Int) === lam[0]x:Int.*0
-- with lam[0]x:Int.*0 === *0
-- tau(Gam, Pi x:Int.Int) === *0

kind Stratum :: *1 where
  Ground :: Stratum -- Regular
  Up :: Stratum ~> Stratum -- Regular
  Push :: Stratum ~> Stratum ~> Stratum -- Admin
--  Push :: Stratum Regular ~> Stratum x ~> Stratum Admin
-- deriving Nat(s)

collapse :: Stratum ~> Stratum
{ collapse (Push (Up x) y) } = (Up x)
{ collapse (Up x) } = (Up x)
{ collapse Ground } = Ground

arr2stratum :: * ~> Stratum
{ arr2stratum (a -> b) } = Push (Up Ground) { arr2stratum b }
{ arr2stratum Int } = Ground
{ arr2stratum Bool } = Ground
{ arr2stratum () } = Ground
{ arr2stratum Float } = Ground
{ arr2stratum (a, b) } = Ground

prop Tractable :: * ~> * where
  IntTractable :: Tractable Int
  PairTractable :: Tractable a -> Tractable b -> Tractable (a, b)
  ArrTractable :: Tractable a -> Tractable b -> Tractable (a -> b)

-- --------- From       To
data Henk :: Stratum ~> Stratum ~> *0 where
  Lit :: Tractable a => a -> Henk { arr2stratum a } Ground
  Bind :: Label l -> Henk Ground (Up strat) -> Henk from to -> Henk (Push (Up strat) from) to
--  Func :: (a->b) -> Henk (Up Ground) Ground -- use Lit and {arr2stratum + cleaner}
--  Ref :: Label l -> Henk Ground strat
  Type :: Henk Ground (Up Ground)
  Star :: Henk Ground (Up (Up g))
  -- Application
  App :: Henk (Push (Up s) from) u -> Henk Ground s -> Henk from u


--a :: Henk Ground Ground
--a = Ref `a

--canon :: Henk strat to -> Henk { collapse strat } to
--canon (Bind l (q@Type) (r@Type)) = Type

tau :: Henk strat to -> Henk strat (Up to)
--tau (Bind l q r) = Bind l q (lazy tau r)
--tau (Bind l (q@(Lit _)) (r@(Lit _))) = tau r
--tau (Bind l (q@Type) (r@Type)) = Type
tau (Bind l q r) = Bind l q (tau r)
--tau (a@Lit) = tau (Bind `ignore a a)
--tau (Lit _) = Type
tau (t@Type) = Star
tau (s@Star) = Star

kind HasHenk :: *1 where {}

--eval :: Row HasHenk -> Henk st s -> Henk st s
eval :: Int -> Henk st s -> Henk st s
eval _ (App (Bind l q r) inp) = r
eval _ other = other
