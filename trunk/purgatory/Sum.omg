-- Discriminated sums as injections



-- TODO:
--  * make 'constr' total by tracking the tags of injections in 'Sum' as a type index
--  * implement recursive/parameterized sums
--  * catas, anas etc. (E. Meijer et al.)

injtype :: Tag ~> * ~> *
{injtype `Le a} = Int -> a
{injtype `Mi a} = [Char] -> a
{injtype `Ri a} = Bool -> a -> a

sumtype :: Tag ~> *
{sumtype `Test} = Test
--{sumtype  } = 
--{sumtype  } =

data Injections :: Tag ~> * ~> * where
  None :: Injections t f
  Inj :: Label cn -> {injtype cn f} -> Injections t f -> Injections t f
 deriving Record(is)

data Sum :: Tag ~> * ~> * where
  Constrs :: Label sn -> Injections sn {sumtype sn} -> Sum sn {sumtype sn}
 deriving Pair(sum)

constr :: Sum sum {sumtype sum} -> Label constr -> {injtype constr {sumtype sum}}
constr (l, {c'=inj; cs}is)sum c = case sameLabel c c' of
                                  L Eq -> inj
                                  _ -> constr (l, cs)sum c


data Test :: * where
  Le :: Int -> Test
  Mi :: [Char] -> Test
  Ri :: Bool -> Test -> Test
 deriving syntax(test) Item(Mi)


t0 = (`Test, {`Le=Le,`Mi=Mi,`Ri=Ri}is)sum
t1 = constr t0 `Mi "Hello World!"

