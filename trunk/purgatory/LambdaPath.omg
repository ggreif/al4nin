-- make lambda terms indexed by a custom kind
-- and allow paths poke into its innards

data Dir :: *1 where
  Down :: Dir ~> Dir
  Left :: Dir ~> Dir
  Right :: Dir ~> Dir

-- Shape for lambda terms
data LT :: Dir ~> *1 where
  AbsLT :: LT (Down a) ~> LT a
  AppLT :: LT (Left a) ~> LT (Right a) ~> LT a
  RefLT :: LT a
  NoNameLT :: LT a
  NameLT :: Tag ~> LT (Down a) ~> LT a
 deriving syntax(sh) Item(AbsLT) LeftPair(AppLT) Unit(RefLT) List(NoNameLT, NameLT)

-- Path into a valid shape
data Path :: LT d ~> * where
  Down :: Path a -> Path (AbsLT a)
  Left :: Path a -> Path (AppLT a b)
  Right :: Path b -> Path (AppLT a b)
  Stop :: Path a

-- Key insight (for now) is that the semantics
-- of lambdas and applications occurs _in place_
-- whereas references possess semantics from
-- another place, so each term must have two indices:
--  o where it is located
--  o where the semantics is

-- Open questions:
--   . Referencing a Lam does automatically reference the bound variable?
--   . should we only count binders when using Up?
--   . should we use names in referentials?

-- Terms

data Term :: Dir ~> LT d ~> * where
  Lam :: Term (Down p) a -> Term p (AbsLT a)
  App :: Term (Left p) a -> Term (Right p) b -> Term p (AppLT a b)
  -- constituent references
  Here :: Term p RefLT
  Up :: Term p RefLT -> Term (d p) RefLT
  -- referentials
  Naked :: Term a []sh
  Ext :: Label n -> Term (Down p) r -> Term p [n; r]sh
 deriving syntax(q) Item(Lam) LeftPair(App) Nat(Here, Up) List(Naked, Ext)


-- Example: \x f a = f a
e1 :: Term root (AbsLT (AbsLT (AppLT RefLT RefLT)))
e1 = Lam (Lam (App (Up $ Up $ Up Here) (Up $ Up Here)))
(Lam (Lam (App (Up (Up (Up e1h1))) (Up (Up e1h2))))) = e1

-- this system doesn't admit flawed references:
##test "reaches out into free realm"
  e1' :: Term root (AbsLT (AbsLT (AppLT RefLT RefLT)))
  e1' = Lam (Lam (App (Up $ Up $ Up $ Up Here) (Up $ Up Here)))
-----------------------^---------------------------

grab :: Path sh -> Term p sh -> Maybe Int
grab (Down r) (Lam b) = grab r b
grab (Left r) (App l _) = grab r l
grab (Right r) (App _ r') = grab r r'
grab Stop _ = Just 25

