-- make lambda terms indexed by a custom kind
-- and allow paths poke into its innards

data Dir :: *1 where
  Down :: Dir ~> Dir
  Left :: Dir ~> Dir
  Right :: Dir ~> Dir
  

data LT :: Dir ~> *1 where
  AbsLT :: LT (Down a) ~> LT a
  AppLT :: LT (Left a) ~> LT (Right a) ~> LT a
  TipLT :: LT a


-- Key insight (for now) is that the semantics
-- of lambdas and applications occurs _in place_
-- whereas references possess semantics from
-- another place, so each term must have two indices:
--  o where it is located
--  o where the semantics is

-- Terms

data Term :: Dir ~> (LT d) ~> * where
  Lam :: Term (Down p) a -> Term p (AbsLT a)
  App :: Term (Left p) a -> Term (Right p) b -> Term p (AppLT a b)
  -- constituent references
  Here :: Term p TipLT
  Up :: Term p loc -> Term (d p) loc


-- Example: \x f a = f a
e1 :: Term root (AbsLT (AbsLT (AppLT TipLT TipLT)))
e1 = Lam (Lam (App (Up $ Up $ Up Here) (Up $ Up Here)))
(Lam (Lam (App (Up (Up (Up e1h1))) (Up (Up e1h2))))) = e1

-- this system doesn't admit flawed references:
##test "reaches out into free realm"
  e1' :: Term root (AbsLT (AbsLT (AppLT TipLT TipLT)))
  e1' = Lam (Lam (App (Up $ Up $ Up $ Up Here) (Up $ Up Here)))
----------------------------^----------------------


