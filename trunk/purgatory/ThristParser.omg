-- -*-Haskell-*-

{-
 * Copyright (c) 2007 Gabor Greif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 -}

-- Usage:
--
--  Set up the environment
--     setenv LD_LIBRARY_PATH /opt/exp/gnu/lib:$LD_LIBRARY_PATH
--     setenv PATH /home/ggreif/%NoBackup%/Omega1.4.1:$PATH
--
--  Start the omega interpreter by typing
--     omega ThristParser.omg
--  and run your commands on the prompt
--

import "LangPrelude.prg" 
  (head,tail,lookup,member,fst,snd,map,Monad,maybeM,id,ioM,Row,HasType,RCons,RNil,Eq,Equal,
  listM, foldl, foldr)


data Thrist :: forall (l :: *1) . (l ~> l ~> *)  ~> l ~> l ~> * where
  Nil :: Thrist k a a
  Cons :: k c b -> Thrist k b a -> Thrist k c a
 deriving List(l)


data Parse :: *0 ~> *0 ~> *0 where
  Atom :: Char -> Parse Char Char       -- exact match
  Pred :: (a -> Bool) -> Parse a a      -- conditional match
  Sure :: (a -> b) -> Parse a b         -- always matches and converts
  Try :: (a -> Maybe b) -> Parse a b    -- pipeline stops if no match
  Rep :: Parse a b -> Parse [a] ([b], [a])    -- consume as many as matches
  Group :: [Parse a b] -> Parse [a] [b] -- all must match
  CataStar :: ([a] -> b) -> Parse [a] b
  CataPlus :: ([a] -> b) -> Parse [a] b
  Wrap :: Thrist Parse a b -> Parse a b

letter = (Atom :: Char -> Parse Char Char)
char = Sure (id :: Char -> Char)
digit = Try (\c -> if ord '0' <= ord c && ord c <= ord '9' then Just (ord c - ord '0') else Nothing)

hexdigit = Try (\c -> if ord '0' <= ord c && ord c <= ord '9' then Just (ord c - ord '0') else
                      if ord 'a' <= ord c && ord c <= ord 'f' then Just (ord c - ord '0') else Nothing)

crop = Try (\(good, rest) -> Just good)

num = Wrap #[Rep digit, Try (\(good, rest) -> Just good), CataPlus (foldl (\acc x -> (acc * 10) + x) 0)]l


abcd = Group [letter 'a', letter 'b', letter 'c', letter 'd']

-- ###############################
-- ############ parse ############
-- ###############################

parse :: Thrist Parse a b -> a -> Maybe b

parse Nil a = Just a

parse (Cons (Atom a) r) b = if ord a == ord b then parse r b else Nothing

parse (Cons (Sure f) r) a = parse r (f a)

parse (Cons (Try f) r) a = do { b <- f a; parse r b } where monad maybeM

parse (Cons (Rep p) r) as = parse r (parseRep p as) where
      parseRep :: Parse a b -> [a] -> ([b], [a])
      parseRep _ [] = ([], [])
      parseRep p (a:as) = case parse #[p]l a of { Nothing -> ([], a:as); Just b -> (b:bs, rest) where (bs, rest) = parseRep p as }

parse (Cons (Group ps) r) as = do { bs <- parseGroup ps as; parse r bs } where
      monad maybeM
      parseGroup :: [Parse a b] -> [a] -> Maybe [b]
      parseGroup [] _ = Just [] -- overlength input
      parseGroup _ [] = Nothing -- input too short
      parseGroup (p:ps) (a:as) = do { b <- parse #[p]l a; bs <- parseGroup ps as; return (b:bs) }

parse (Cons (CataStar f) r) a = parse r (f a)

parse (Cons (CataPlus _) _) [] = Nothing

parse (Cons (CataPlus f) r) a = parse r (f a)

parse (Cons (Wrap thr) r) a = do { a' <- parse thr a; parse r a' } where monad maybeM

