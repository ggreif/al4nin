import "LangPrelude.prg"

data Scope :: *1 where
  Global :: Scope
  Nest :: Scope ~> Scope
 deriving Nat(s)

kind Kind = Acc | Prod

data Exp :: Kind ~> Scope ~> * where
  -- Accessors
  Here :: Exp Acc (1+s)s
  Surrounding :: Exp Acc s -> Exp Acc (1+s)s
  -- Producers
  Lam :: Exp k (1+s)s -> Exp Prod s
  App :: Exp k s -> Exp k' s -> Exp Prod s
  In :: Exp Prod 0s -- junk, never terminates a Let!
  Let :: Label name -> Exp k s -> Exp k' (1+s)s -> Exp Prod s
 deriving syntax(e) Record(In, Let) LeftPair(App) Item(Lam) Nat(Here, Surrounding)

-- raise scope
unnest :: Exp k (1+s)s -> Maybe (Exp k s)
unnest (1+v)e = Just v
unnest In = unreachable
unnest (f,a)e = do { f' <- unnest f; a' <- unnest a; return (f',a')e } where monad maybeM
unnest (e)e = do { e' <- unnest e; return (e')e } where monad maybeM
unnest {n=e;r}e = do { e' <- unnest e; r' <- unnest r; return {n=e';r'}e } where monad maybeM
unnest _ = Nothing

-- eta conversion
eta :: Exp k' s -> Maybe (exists k . Exp k s)
eta ((f, 0e)e)e = do { f' <- unnest f; return (Ex f') } where monad maybeM
eta _ = Nothing
