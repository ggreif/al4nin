@SysInclude { report }
@SysInclude { fig }
@SysInclude { diag }
@SysInclude { graph }
@SysInclude { eq }
@SysInclude { haskell }

def @Prompt left input right output { { Helvetica Base } @Font { prompt> @Haskell { input } @PP @I { output } } }
def @Omega { {@Sym Omega}mega }

#@Database @Reference { refs }
@Report
  @CoverSheet { No }
  @ColumnNumber { 2 } 
  @InitialFont { Palatino Base 9p } 
  @DateLine { Yes }
  @Title { Thrists: Dominoes of Data }
  @Author { Gabor Greif }
  @Institution { gabor@mac.com }
#  @SectionHeadingFont { Helvetica Bold }
  @AbstractDisplay { Yes }
# @AbstractFormat { @Centre @Title @DP @Body }
@Abstract {
We develop a novel list-like datastructure (which we name @I Thrist),
that is able to capture the typing rule of function composition.
Indeed, we show that when Thrist is parameterized with the function
type constructor @Haskell {(->)} we can provide an interpretation function
which completely emulates the classical function composition @Haskell {(.)}.
Additionally we can perform pattern matching on our Thrist elements, thus
obtaining the ability to do analysis on them. On the practical side
we develop two new two-parameter GADTs. The first, when accompanied
by an appropriate interpreter, directly model the semantics of the Cat language,
while the second caters for a new type of parser combinator libraries.
The Thrist approach of exposing the intermediate types where the
elements are joined together especially shows its potential in the ability to
stage the interpreter in a type-safe way and only allows for type correct
transformations.
}
//

@Section
@Title { Structure of the Paper }
@Begin
@PP

In the first section we motivate our later introduction of Thrist with well known
examples. In the third section we develop three practial applications of Thrists.
We also present some less useful but entertaining uses. Section four shows
up possible future directions and summarizes open problems. Section five concludes.
@End @Section

@Section
@Title { Introduction }
@Begin
@PP
We are well acquainted with data structures that are parameterized over
data types, they are the bread-and-butter tool of functional programmers.
For example the List datatype could be introduced in Haskell with the following
definition:
@PP
@ID @Haskell {
data List :: * ~> * where
  Nil :: List a
  Cons :: a -> List a -> List a
}
@PP
We deliberately avoid the traditional syntax of defining the @Haskell {List} datatype,
and use a @I {GADT-style} definition{@FootNote {in a @I {generalized algebraic datatype}
the data constructor is allowed to define a more specific type than the datatype itself }},
because we want to build on this fundament later.
It is enough to say that @Haskell {List} does not impose any constraints on the
contained datatype whatsoever:
@LD {
{Cons 42 (Cons 33 (Cons 5 Nil))} @Prompt
  { Cons 42 (Cons 33 (Cons 5 Nil)) :: List Int }
}

Departing from single-parameter datatypes we focus on two-parameter
datatypes from now on. These are more interesting for our purposes,
because the two parameters can be put in relation to each other.
The most prominent member of this class of types is the arrow type:

@LD {
{ :k (->) } @Prompt
  { (->) :: *0 ~> *0 ~> *0 }
}

Fully saturated, @Haskell {a -> b} signifies the type of all functions that take elements of @Haskell {a} to
elements of @Haskell {b}. Again, @Haskell {a} and @Haskell {b} can be any type, concrete ones will do just like
universally qualified ones:
@LD {
{id} @Prompt
  {<fn> : forall a.a -> a}
}
@RLD {
{ord} @Prompt
  {<primfun to1> : Char -> Int}
}
@LP
Now, functions are a bit more interesting than Lists above, they can be composed!
Interestingly, composition (written as (.)) is again a function:
@LD {
{(.)} @Prompt
  {<fn> : forall a b c.(a -> b) -> (c -> a) -> c -> b}
}
This function signature has several interpretations, but the most common one tells us that
the composition function @Haskell {(.)} takes a function with type @Haskell {a -> b} as its first argument, then
a function with type @Haskell {c -> a} as its second argument, and returns a function of type @Haskell {c -> b}.
Again, a, b and c can be arbitrarily specialized or be left universal.
We can play with our new toy in the following way:

@LD {
{ let locase = chr . ("\\"x -> x + 32) . ord } @Prompt
{ locase }
}
@RLD {
{  locase 'G' } @Prompt
{  'g' : Char }
}
@LP
The type of the composition function constrains the types of its arguments in
a nontrivial way: the range of the second funtion must match with the domain
of the first. (Universal types will always match, monotypes must be equal).
Violating this rule gives a type error:

@LD {
{ ord . ord } @Prompt
{
In the expression: ord
the result type: Char -> Int
was not what was expected: a -> Char
}
}

This crucial property of the composition function will guide our explorations in this
paper.

@BeginSubSections

@SubSection
@Title { Generalizing Function Composition }
@Begin
@PP
While function composition seems to be a cute artifact of mathematics, (where
nevertheless all computable functions can be derived from), this is no reason
for us to stop at this point! First, we observe that function composition is a one-way
street: once two functions are composed, they amalgamate beyond recognition.
There is no way (inside our system) to take them apart again. This is very much
resembling the addition, where @Haskell { (23 + 19) } gives @Haskell {42} and this result has completely
lost all memories of the fact how it was obtained. But can we create a datastructure
that has all properties of function composition, without being amnesiac?
@PP
Indeed we can, and the rest of this chapter shall explain how.
@PP
Our crucial observation from the introduction was that the types at the ends of the function
arrows must thread up, intuitively @FootNote { we reconcile the conflict between
the function arrow's @Haskell {(->)} direction and the customary
composition @Haskell {g . f} by considering a modified @I {reverse composition} }:

@ID { @Haskell {a ->} @Box @Haskell {b (.) b} @Haskell {-> c} @Sym equivalence @Haskell {a -> c} }

We also observe that the intermediate types do not show up in the end result's type.

Let's simulate these rules as a datatype:

@ID @Haskell {
data Thrist :: * ~> * ~> * where
  Nil :: Thrist a a
  Cons :: (a, b) -> Thrist b c -> Thrist a c
}

The alert reader will have noticed that we have defined a proper GADT,
since the @Haskell {Nil} constructor is only inhabiting the @I diagonal
of the @I {two-dimensional} parameter space.
@PP
We can now duplicate the @I feeling of function composition:

@Haskell operators {Base} { Cons ('g', 103) $ Cons (103, 71) $ Cons (71, 'G') Nil }

Also we have obtained a datatype that is not amnesiac, i.e. it can be
torn apart at any place by pattern matching, though we have to pay
the price that the intermediate types are a bit hard to deal with
(we shall revisit this issue later).
@PP
It appears that we have reached our goal, we can form list-like data where the intermediate
types thread up, we are happy and name our new toy @I Thrist, a portmanteau of thread and list.
@PP
Our joy, however, quickly fades away when we compare our thrist with the composition function.
How can some data of type @Haskell {Thrist a b} be interpreted as an arrow type @Haskell {a -> b}?
If we fail to provide this embedding, we cannot consider thrists being a generalisation of
function composition.
@PP
Not everything is lost, however. Close scrutiny reveals that our usage of
@Haskell {(,)}{@FootNote { pronounced "\"pair\""}},
is the culprit. If we could liberate ourselves from this
premature decision, we could gain back our hope.
@End @SubSection

@SubSection
@Title { The Improved Thrist }
@Begin
@PP
We try all over again, this time abstracting away the pair into an additional parameter:

@ID @Haskell {
data Thrist :: (* ~> * ~> *) ~> * ~> * ~> * where
  Nil :: Thrist p a a
  Cons :: p a b -> Thrist p b c -> Thrist p a c
}
All that remains of the pair is the bitter aftertaste
and the letter @Haskell {p} in the definition of @Haskell {Thrist}.
@PP
It looks like we are getting closer now:
@LD {
{ Cons chr (Cons ("\\"x -> x + 32) (Cons ord Nil)) } @Prompt
{ ... : Thrist (->) Char Char }
}
We have created an @I {arrow thrist}!

Immediately we can retry our previous attempt:
@LD {
{ Cons ('g', 103) (Cons (103, 71) (Cons (71, 'G') Nil)) } @Prompt
{  ... : Thrist (,) Char Char }
}
The @I {pair thrist} that caused us some headache before!
@PP
We shall explore some other interesting but sometimes futile
thrists later in the discussion. But now let's put the last missing
piece in place to show that an arrow thrist is strictly more general
than function composition, the @Haskell {runArrowThrist} function:

@ID @Haskell {
runArrowThrist :: Thrist (->) b c -> c -> b
runArrowThrist Nil b = b
runArrowThrist (Cons f r) a = runThrist r (f a)
}

This function now confirms the vague intuition that @Haskell {Nil} plays the r{@Char ocircumflex}le of
the neutral element of the arrow thrist, just like the identity function
plays the r{@Char ocircumflex}le of the neutral element in the monoid of composed functions.
We shall encounter this recurring fact as we proceed to our implementations.
@LP The definition of @Haskell { runArrowThrist } on a @Haskell { Cons } constructor
deserves some attention. We have not yet explicitly mentioned it, but range of
the function @Haskell { f } is existentially qualified, because it does not
appear in the final result of @Haskell { Cons }. This implies a minor complication
when pattern matching: the {@I head} component{@FootNote {or for symmetry reasons the {@I tail} too} }
of a @Haskell { Cons } cannot be
passed to non-local functions, because the existential type would escape.
@PP
@Considerations {
[Question: is every thrist a monoid? "http://en.wikipedia.org/wiki/Monoid"]
}
@PP
Looking back at our progress so far, the analogy of thrists with the game of
dominoes ("http://en.wikipedia.org/wiki/Dominoes") could spring into our minds:
@LP Dominoes are laid out in a valid configuration only, when the stones sharing a common
edge possess the same number of dots next to this edge. Our @Haskell {Nil}
corresponds to an empty board, and @Haskell { Cons } joins two stones with
a common edge.

@End @SubSection

@EndSubSections

@End @Section

@Section
@Title { Three Practical Thrists }
@Begin
@PP

Now that we have defined the Thrist datatype and gave a sufficiently
generic interface to cover nontrivial cases, time has come to look for
real-world applications. Specifically we shall describe a combinator
library for creating ASTs of the Cat language, a statically typed stack-
oriented language ("http://www.cat-language.com/"), and a parser
combinator library. We shall sketch the use of thrists in transition
arrows of state machines and finally give some curious examples
that may have some practical value.

@BeginSubSections

@SubSection
@Title { Application one: the Cat Thrist }
@Begin
@PP
Like all stack-oriented languages Cat employs a simple idiom of
computation. A rich set of primitives are available for pushing
values on a stack, permuting them and popping them off. Logical
and arithmetic primitives consume portions of the top of the stack
(TOS) and deposit results in their place. Procedures can be defined
as a succession of primitive invocations and procedure calls.
The semantics of procedure calls is defined as the insertion of the
called procedure's contents to the point of the invocation.
@PP
Let's begin with the definition of the Cat datastucture, that will
serve as the first parameter to Thrist. Clearly it should be
parametrized with two types. Naturally we choose the
first type parameter to describe the shape of the stack before
and the second parameter after the Cat primitive has been
executed.

@ID @Haskell {
data Cat :: * ~> * ~> * where
  Push :: a -> Cat opaque (a, opaque)
  Pop :: Cat (a, opaque) opaque
  Dup :: Cat (a, opaque) (a, (a, opaque))
  Add :: Cat (Int, (Int, opaque)) (Int, opaque)
}

@BeginSubSubSections

@SubSubSection
@Title { First Explorations }
@Begin
@PP
We shall extend our Cat with new primitives as the need arises, but
for now we have enough to perform some experiments.
We have chosen the tuple datatype to represent stack shapes,
but we are free to pick any other sequence-like datatype that
is able to record the type of each element.
The Cat datatype is defined as a GADT, which will guarantee
that only sematically sound programs can be expressed as a
Thrist Cat. We can begin our explorations immediately:
@LD {
{ Cons (Push 19) $ Cons (Push 23) $ Cons Add $ Cons Pop Nil } @Prompt
{ Cons (Push 19) (Cons (Push 23) (Add (Cons Pop (Cons Add (Cons Pop Nil)))) :: Thrist Cat a a }
}
The data we built up can be a representation of a Cat program that
pushes 19 and then 23 on the stack, adds them, keeping only the
result 42 on the stack, and then pops this result off. The inferred type
tells us that there is no netto change in the stack's shape.

@End @SubSubSection


@SubSubSection
@Title { Making Use of @Omega{}'s features }
@Begin
@PP
We shall from now on make use of a feature of the @Omega language
to define custom syntax for datatypes. Our aim is to hide the
Thrist constructors Cons and Nil behind a more intuitive façade.
We shall write the above expression as

@LD {
{ [Push 19, Push 23, Add, Pop]l } @Prompt
{ [Push 19, Push 23, Add, Pop]l :: Thrist Cat a a }
}
@Omega's parser and printer perform the conversion to
the internal form when the list-like brackets @Haskell {[]} followed
by the letter "\"l\"" are encountered.
@PP
We can now continue using this terser syntax:

@LD {
{ [Pop, Pop]l } @Prompt
{ [Pop, Pop]l :: Thrist Cat (a, (b, c)) c }
}

The inferred type reflects the function of this Cat fragment,
namely starting out with a stack that has at least two elements
pushed, we end up with those two values removed.

There are invalid Cat programs, for example addition of two
characters:

@LD {
{ [Push 'a', Dup, Add]l } @Prompt
{ TYPE ERROR (TODO) }
}

The GADT-based type inference fails, because Add
expects two integers on the stack, but there are two
Chars available instead.
@End @SubSubSection

@SubSubSection
@Title { Interpreter }
@Begin
@PP
Now it is time to build an interpreter for Thrist Cat, and
thus define its big-step semantics:
@ID @Haskell {
interpret' :: Thrist Cat a b -> a -> b
interpret' []l st = st
interpret' [Push x; rest]l st = interpret' rest (x, st)
interpret' [Pop; rest]l (a, st) = interpret' rest st
interpret' [Dup; rest]l (a, st) = interpret' rest (a, a, st)
interpret' [Add; rest]l (a, b, st) = interpret' rest (a + b, st)
}
It works:

@LD {
{ interpret' [Push 19, Push 23, Add]l () } @Prompt
{ (42, ()) :: (Int, ()) }
}

With this basic functionality in place, we get bolder and define
a primitive with side effect:

@ID @Haskell {
data Cat :: * ~> * ~> * where
  Print :: Cat (a, opaque) opaque
  ...
}

To interpret the @Haskell {Print} primitive we have to restructure
our @Haskell {interpret'} function to wrap the stack into the @Haskell {IO} monad:

@ID @Haskell operators {Base} {
interpret' :: Thrist Cat a b -> IO a -> IO b
interpret' [Print; rest]l st = do
	(a, st') <- st
	putStr $ show a
	interpret' rest st'
  where monad ioM
}
In similar spirit we have to rewrite the other cases too:

@ID @Haskell operators {Base} {
interpret' [Pop; rest]l st = do
	(a, st') <- st
	interpret' rest $ return st'
  where monad ioM

interpret' [Push x; rest]l st = do
	interpret' rest $ return (x, st)
  where monad ioM

interpret' [Dup; rest]l st = do
	(a, st') <- st
	interpret' rest $ return (a, a, st')
  where monad ioM

interpret' [Add; rest]l st = do
	(a, b, st') <- st
	interpret' rest $ return (a + b, st')
  where monad ioM
}
Trying out this monadic interpreter gives us:
@LD {
{ interpret' [Push 21, Dup, Add, Print]l (returnIO ()) } @Prompt
{ Executing IO action
@LP 42
@PP () :: IO () }
}

It is a reasonable restriction to Cat programs that they can
be started with any stack shape and they finish with the same
stack unchanged. We can ensure this property by writing
a top-level interpreter function for Cat programs using
@I {rank-2 polymorphism}:

@ID @Haskell {
interpret :: (forall a . Thrist Cat a a) -> IO ()
interpret program = interpret' program (returnIO Empty)
}
Obviously this @Haskell {interpret} function is only called for side-effects.
@End @SubSubSection

@SubSubSection
@Title { Extending the Primitives }
@Begin
@PP

Above we have defined an arithmetic primitive in Cat, namely Add. While possible,
it is not desired to define all (which is potentially a lot) primitives this
way, with their own typing rules, and own clause in the interpreter. Also,
this approach does preclude a very useful notion, called partial application. In this
example, Add must always be applied to two elements on the stack.
@PP What we are looking for is a more-or-less generic approach to define
logical and arithmetic operators in Cat, say, using the @Haskell { Prim (+) }
to frob arithmetic addition from the underlying @Omega implementation.

@LD @Heading { Encountering First Problems }
We could introduce @Haskell { Prim } thus:
@ID @Haskell {
  Prim :: (a -> b) -> Cat (a, opaque) (b, opaque)
  ...
}
While this approach can surely be made to work with unary functions,
it is not immediately seen how binary @FootNote { or arbitrary arity functions for that matter }
can be formalized in the type-safe way mandated by @Omega{.}
The expectation is that a binary primitive would consume the top @Haskell { n } items from the
stack and produce one item as the result.
@LP We have to reformulate our typing rule to deal with the case that
the type parameter @Haskell { b } is in turn a function arrow. Since @Omega
allows us to decompose the arrow's structure using a type function, we try:
@ID @Haskell {
  Prim :: (a -> b) -> Cat {blowUpBy (a -> b) opaque} ({result b}, opaque)
  ...
}
@Haskell { blowUpBy } @FootNote { see the definition of @Haskell { blowUpBy }
and @Haskell { result } in the Appendix } creates the expected stack shape needed
for fully saturating the primitive, while @Haskell { result } determines the
rightmost type in the function's type.
With these definitions we can observe the correct type inference of our @Haskell { Add }
substitute @Haskell { Prim (+) }:
@LD {
{ Prim (+) } @Prompt
{ Prim <fn> :: Cat (Int, Int, a) (Int, a) }
}

@LD @Heading { More Problems while Interpreting }
Unfortunately we have not mastered everything yet. We remember that
the semantics of our Cat combinators is defined by the interpretation
function. So we are obliged to extend @Haskell { interpret }. We can try thus:

@TODO


@LD @Heading { Using Witnesses to Describe Arities }
The solution is to attach a @I witness object to every @Haskell { Prim }
combinator, to aid continued interpretation in the multi-arity case.
@LP To this end we need a description of what types are being passed in
stack slots. This desctiption must be a value so that it can be pattern
matched at runtime and it has to provide a constructor for all tractable
datatypes.

@ID @Haskell {
data Tractable :: * ~> * where
  IntT :: Tractable Int
  BoolT :: Tractable Bool
  CharT :: Tractable Char
  PairT :: Tractable a -> Tractable b -> Tractable (a, b)
  ListT :: Tractable a -> Tractable [a]
  ArrT :: Tractable a -> Tractable b -> Tractable (a -> b)
}

provides a way to describe some data types that are built into @Omega{.} Its
first three constructors apply to basic datatypes, while the rest encodes
rules, how compound datatypes can be represented, given tractable ones.
@PP We can proceed by employing this descriptive facility into our @Haskell { Prim }
constructor:

@ID @Haskell {
  Prim :: Tractable b -> (a -> b) -> Cat {blowUpBy (a -> b) opaque} ({result b}, opaque)
  ...
}

The first argument to @Haskell { Prim } is called a @I witness{ @FootNote { technically
these types are called @I { singleton types } and constitue a reflection of the structure
of the type-level objects into the value-world. }}, becase it records the
structure of the function's range's type{ @FootNote { It suffices to describe the range, because
the domain's type is easily handled without a witness. } }.
@LP We can reproduce our previous @Haskell { Add } primitive now:

@LD {
{ Prim (ArrT IntT IntT) (+) } @Prompt
{ Prim (ArrT IntT IntT) (+) <fn> :: Cat (Int, Int, a) (Int, a) }
}

@LD @Heading { Interpreting Primitives }
We finally have all ingredients together to embark on putting down the @Haskell { interpret }
case on @Haskell { Prim }. The key idea is here to pattern match on the witness in order
to incrementally saturate the @Omega function present in the primitive:

@TODO


@End @SubSubSection

@SubSubSection
@Title { Staging the Interpreter }
@Begin
@PP
A well-known technique to turn an interpreter into a compiler
is staging. The compile function takes a Thrist Cat into
a function of the metalanguage, that when executed causes the
same effect as the interpretation of the program itself. Naturally,
the compiled program is expected to run faster, since the interpretative
overhead is already removed.

We demonstrate the technique for a selection of the Cat primitives
only.

@ID @Haskell operators {Base} {
compile' :: Thrist Cat a b -> Code (IO a -> IO b)
compile' [Print; rest]l = [| \st -> do
	(a, st') <- st
	putStr $ show a
	$compiledRest st'
    where monad ioM |]
  where compiledRest = compile' rest
}

[TODO: Push, etc.]

@End @SubSubSection

@SubSubSection
@Title { Optimization }
@Begin
@PP
The fact that Cat programs are represented as data in the metalanguage
that is amenable to analysis by pattern matching, we can write an optimization function
that performs several code optimizations on a program, such as head and tail merging
of conditionals, value folding, inlining etc. Because the Cat thrist does not admit wrongly
typed Cat programs and the optimization function takes Thrist Cat to Thrist Cat,
all optimizations must be type preserving.
@End @SubSubSection

@SubSubSection
@Title { Generalization }
@Begin
@PP
The language Cat is intended as an intermediate language produced by
front-end compilers and consumed by back-ends that target stack based
virtual machines like JVM and CIL. It is advisable to generalize Cat in a way
that Pop gets a count parameter that tells how many elements are to be
popped of the stack. Also instead of Swap it would be beneficial to have
a Permute primitive that subsumes all variants of stack shuffling operations,
allowing us to get rid of Swap and friends. All these parametrized primitives
would have one problem in common, namely that the stack shape would
vary depending on the  value of the parameter(s), requiring dependent
types to define them. Fortunately @Omega provides a device that is approaching
the power of dependent types, singleton types and type-level functions.

Here is a sketch of PopN:

@ID @Haskell {
  PopN :: Nat' (S n) -> Cat {blow (S n) s} s
}
It uses the type-level function blow to add the
necessary number of universal type variables
to the initial stack's shape:

@ID @Haskell {
blow :: Nat ~> *0 ~> *0
{blow Z s} = s
{blow (S n) s} = (t, {blow n s})
}
The interpreter can be written thus:

@ID @Haskell {
interpret [PopN (S n); rest]l st -> do
	(_, st') <- st
	case n of
	0v -> interpret' rest st'
	_ -> interpret' [PopN n; rest]l st'
}

@End @SubSubSection

@EndSubSections

@End @SubSection


@SubSection
@Title { Application two: a GADT-based Parse Thrist }
@Begin
@PP
Traditional monadic parser combinator libraries (like Parsec) suffer from the
same problem like the composition operator: they compose easily
but cannot be dissected and analysed, or translated to other
representations. We proceed similarly to the Thist (->) and Thrist Cat to
create a parsing combinator library that is representation agnostic, i.e.
can be interpreted or compiled and analysed in any reasonable way.



@BeginSubSubSections

@SubSubSection
@Title { Envisioning Parsing }
@Begin
@PP

But first let's be clear about what we aim at. We demonstrate the process of
parsing by the example of a lexer with semantic evaluation. Our tokens
are the various literal numerals like they occur in the C language:
@ID @F {0xCafeBabe 0XE0UL 123456L}
These are the steps we wish to proceed on the second token:

0) token as read from character stream:

@ID @F 0XE0UL

1) We match the @F "0X" prefix:
@ID @F {{@Box 0X}E0UL}
--
2) We expect zero or more hexadecimal characters (we come to the explanation of why zero, later)
@ID @F {{@Box 0X}{@Box E0}UL}
3) We fold the hex string found to a decimal integer
--++
@ID @F {{@Box 0X}{@Box {@Box E0}}UL}
--++
  vv

4) We look for optional signedness hint
@ID @F {{@Box 0X}{@CurveBox {@Box E0}}{@Box U}L}

--++u
  vv

5) We look for optional storage size hint

@ID @F {{@Box 0X}{@Box {@Box E0}}{@Box U}{@Box L}}
--++us
  vv

6) we encapsulate the distilled information into a token datatype

@ID @F @Box {{@Box 0X}{@Box {@Box E0}}{@Box U}{@Box L}}
--++us
  vv
tttttt

@End @SubSubSection

@SubSubSection
@Title { Realization }
@Begin
@PP

To be able to compose these operations we define the GADT Parse:

@ID @Haskell {
data Parse :: * ~> * ~> * where
  Epsilon :: Parse [a] ([b], [a])       -- always match, return everything
  Atom :: Char -> Parse Char Char       -- exact match
  Sure :: (a -> b) -> Parse a b         -- always match and convert
  Try :: (a -> Maybe b) -> Parse a b    -- pipeline stops if no match
  Rep1 :: Parse a b -> Parse [a] ([b], [a])          -- consume as many as matches found, return rest
  Rep :: Parse [a] (b, [a]) -> Parse [a] ([b], [a])  -- consume as many as matches, return rest
  Group :: [Parse a b] -> Parse [a] ([b], [a])       -- all must match, return rest
  CataPlus :: ([a] -> b) -> Parse ([a], c) (b, c)    -- collapse one or more elements
  Par :: Parse a b -> Parse c d -> Parse (a, c) (b, d)
  Wrap :: Thrist Parse a b -> Parse a b
}

The datatype Parse a b represents a parser that consumes data of type a
and if a match is found produces data of type b.

@DashList
@ListItem {  (Atom 'X') matches only the capital X character }
@ListItem {  Epsilon matches a zero-size prefix of a list of as and returns an empty list of bs along with the unconsumed rest of as }
@ListItem {  (Sure ord) alway matches, consuming a Char and returning its Int ASCII value }
@ListItem {  (Try hexdigit) matches only if a characker is a hexadecimal one and returns its hex value, fails otherwise }
@ListItem {  (Rep1 (Atom 'X')) matches as many capital Xs as possible and returns a pair consisting the matched and unconsumed portions }
@ListItem {  (Group [Atom 'a', Atom 'b']) matches only a prefix "ab" in the input, returning it in a pair along with the unmatched portion or fails otherwise }
@ListItem {  (CataPlus foldDec) consumes a pair of a list of digits and some other data, if the list is empty it fails, otherwise it folds the sequence to a number, then returns the pair of this number and the other data, which remains unchanged }
@EndList

In the above descriptions we only suggest a possible semantics, the data of type Parse does not mandate it in any way. So when we talked about "returns soandso" then this is just an intention.

The end result of parsing a token will amount to

@ID @Haskell {
data Token =
  Number Int Bool Bool
  | ...
}
So we expect that our parser that produces Tokens to have a type Thrist Parse [Char] ([Token], [Char]).

@End @SubSubSection

@SubSubSection
@Title { Using the Combinators }
@Begin
@PP
How can we use our combinators to describe the parsing steps 0) to 6) above?

First, we use

@Haskell operators {Base} {Group [Atom '0', Atom 'X']}

to match the prefix of the string @Haskell {"0XE0UL"} and
produce @Haskell {("0X", "E0UL") :: ([Char], [Char])}

then we can discard the prefix because we know we have to do base 16 conversion later,
we can use

@Haskell {Sure snd}

to do this obtaining @Haskell {"E0UL" :: [Char]}. Then

@Haskell operators {Base} {Rep1 $ Try hexdigit}

will split off two more characters, converting them to hex values on the way, we obtain ([0, 14], "UL") :: ([Int], [Char]). We cannot
discard either component, so we proceed in parallel with

@LD @Haskell operators {Base} {Par (CataPlus foldHex)
       (Wrap [Rep1 $ Atom 'U', Par (Sure id) (Rep1 $ Atom 'L')]l)
}

the first component produces 14, the second will proceed by splitting of any 'U' and then
splitting off any L producing a triple ("U", ("L", "")).

At this stage we have @Haskell {(14, ("U", ("L", ""))) :: (Int, ([Char], ([Char], [Char])))}.

Finally we feed this into

@LD @Haskell {Try numberToken}

that verifies the correct usage of Us and Ls, and creates a pair

@LD @Haskell {(Number 14 True True, "") :: (Token, [Char])}

of the parsed token and the rest of the input.

Putting this together we can write

@ID @Haskell operators {Base} {
signedSized = Wrap [Rep1 $ Atom 'U', Par (Sure id) (Rep1 $ Atom 'L')]l

hexToken = Wrap [Group [Atom '0', Atom 'X']
  , Sure snd
  , Rep1 $ Try hexdigit
  , Par (CataPlus foldHex) signedSized
  , Try numberToken
  ]l

tokens = Rep hexToken
}

Of course there are some pitfalls here but the principle is clear:
@DashList
   @ListItem { the interesting prefix is split off the rest, }
   @ListItem { if the prefix is semantically important it gets condensed to a more appropriate form or else discarded, }
   @ListItem { parallel processing is used if both components of an input pair are relevant. }
@EndList

@End @SubSubSection

@SubSubSection
@Title { Defining the Semantics by Interpretation }
@Begin
@PP
We provide the parse function for the Rep constructor as an example:

@LD @Haskell {
parse :: Thrist Parse a b -> a -> Maybe b

parse [Rep p; r]l as = parse r (parseRep [p]l as) where
      parseRep :: Thrist Parse [a] (b, [a]) -> [a] -> ([b], [a])
      parseRep _ [] = ([], [])
      parseRep p as = case parse p as of
                      Nothing -> ([], as)
                      Just (b, as') -> (b:bs, rest)
                          where (bs, rest) = parseRep p as'
}

@End @SubSubSection

@SubSubSection
@Title { Compilation }
@Begin
@PP
Similarly to the Thrist Cat we can compile our parser combinators to
a more efficient algorithm by removing the interpretative overhead.

@End @SubSubSection

@SubSubSection
@Title { Analysis }
@Begin
@PP
We can run various analyses on our parsers, to ensure that the grammar is unambiguous, for example.

@End @SubSubSection

@SubSubSection
@Title { Outlook }
@Begin
@PP
Many interesting other combinators can be defined, my repository contains also

  Seq :: Parse [a] (b, [a]) -> Parse [a] (c, [a]) -> Parse [a] ((b, c), [a]) -- parse front first then second
  Seq1 :: Parse a b -> Parse a c -> Parse [a] ((b, c), [a]) -- same, but with single-elem first and second
  ButNot1 :: Parse a b -> Parse a b -> Parse a b     -- match first and expect second to fail
  UpTo :: Parse [a] (b, [a]) -> Parse [a] (c, [a]) -> Parse [a] ((b, c), [a]) -- scan for c then match b

etc.

I think working together with a parsing expert could result in a minimal set of combinators that
allow parsing a great variety of grammars and optimization and compilation methods that make
the parsing process *fast*.
@End @SubSubSection

@EndSubSubSections



@End @SubSection

@EndSubSections

@End @Section


@Section
  @Title { Exotic Uses }
@Begin
@PP
We have already seen @Haskell { Thrist ((,)) } and @Haskell { Thrist (->) } in the introduction.
But several more common two-parameter datatypes exist that @Haskell { Thrist } can be parametrized with,
e.g. @I Either{@FootNote { in @Omega named as @Haskell { (+) } }}, @Haskell { Equal } and so on.
In this section we analyse the formal requirements for inclusion into the @Haskell { Thrist } framework,
constructing adapters as needed, and suggest possible uses.

@BeginSubSections

@SubSection
  @Title { Equal Thrist }
@Begin
@PP
In @Omega the @Haskell { Equal } datatype has two parameters, and is used to
track type equality internally. The @I { Curry-Howard correspondence } is employed
to prove propositions encoded in the types of functions, and the resulting @Haskell { Equal }
types can be introduced by @I { theorem declarations } into the type-checker's
rewrite engine. Typical and useful instantiations of @Haskell { Equal } arise in connection
with type fucntions, e.g. @Haskell { Equal {plus a b} {plus b a} } which is a manifestation
of the @Haskell { plus } type function's commutativity.
@LP When we assert @Haskell { trans :: Thrist Equal a a } and @Haskell { trans } is a non-empty
thrist, then @Haskell { trans } can be interpreted as a transitivity proof:
@TODO

Modelling transitivity.

@PP One could go a step farther and consider a (=>){@FootNote {imaginary @Omega operator} }
relation as a binary datatype, with constructors that encode the implication.
Then @Haskell { circ :: Thrist (=>) a a } could encode circular implications, equating
all intermediate types (propositions).

@PP On a speculative note, one could come up with a proof algebra system that has types of
the form @Haskell { Equal (Equal a b) (Equal c d) } in which the outer @Haskell { Equal }
would signify equivalence of propositions.
@LP Then
@ID @Haskell {
data Proof
  And :: ...
  Impl :: ...
  etc.
}
could serve as a way to formulate proofs

@End @SubSection

@SubSection
  @Title { Connection to Arrows and Monads }
@Begin
@PP
Since arrows in the Haskell world also originated from the generalization of function
composition it is helpful to give a comparison of the @Haskell { Arrow } @I { type class } in Haskell and
our Thrist datastructure. Obviously any instance of the Haskell type class @Haskell { Arrow } can
be expressed as a thrist. We have to accompany the @Haskell { Thrist Arrow } with an interpretation
function that is rather canonic, and will be given in the Appendix. This semantics obviously
guarantees the arrow laws {@Cite { hughes19xx } }. On the other hand thrists are not always
easily fitted in an arrow. It is the @Haskell { arr } instance method that is problematic
to provide. Thrists just serve as a container and do not carry a semantics, while @Haskell { arr }
mandates a function argument for the method @Haskell { arr }.
@PP
Nilsson @Cite { nilsson2005 } embarks on optimization of a GADT-based @Haskell { Arrow } library, but he only
considers the identity function as a special case. He observes a substantial
speedup in microbenchmarks when the optimizer is able to discover and short-circuit
the identity arrow. In @Haskell { ParseThrist } the identity can be written in several ways,
e.g. as @Haskell { Wrap Nil } or as @Haskell { Sure id }. When interpreting, there is probably no
significant win in using the former, when compiling to @Haskell { Code } the underlying
metaprogramming system in @Omega presumably possesses all the information to recover
the identity function from the @Omega interpreter's internals. In case of
translation to a different programming system every function inside of @Haskell { Try } and @Haskell { Sure }
constructors would need auxiliary denotation anyway, and could be optimized
either on export or inside of the external system itself.
@PP
Monads can also be regarded as a specialization to arrows, so we expect that @Haskell { Thrist (Monad' T) }
can be canonically derived.
@LP First we define the adapter to @Haskell { Monad }, @Haskell { Monad' } to have two parameters:
@TODO
@ID @Haskell {
data Monad' :: (* ~> *) ~> * ~> * ~> * where
  Return :: m b -> Monad' m a b
  Bind :: (t -> m u) -> Monad' m t u
}

@End @SubSection


@SubSection
  @Title { Connection to Categories }
@Begin
@PP
encoding free categories as Thrists
@LP every Thrist gives rise to a category?
@LP RevThrist is the opposite category?
@LP commutative diagrams?
@LP limits?
@End @SubSection


@EndSubSections
@End @Section


@Section
  @Title { Other Work }
@Begin
@PP
Chuan-kai Lin's @I { Unimo } framework @Cite {xxx} is an attempt to describe monads operationally
by interpreting a datastructure that describes the monad. The fact that the interpreter
is proven to satisfy the monadic laws, a guarantee is given that the monadic semantics
is fulfilled, regardless what callback functions the monad's creator supplies. GADTs appear in
his work only as the datatypes modelling the effect basis of monads, while they are not needed
for the general case.
@PP
Chris Heunen and Bart Jacobs' work @Cite {xxx} on the connection of Arrows and Monads and their category theoretical
formalisation is of relevance becuse it reveals the mathematical structure behind these constructs.
Arrows appeared in the general mindset as a pragmatic approach to deal with a certain class of parsers
@Cite {hughes2000} that did not fit into the monadic framework.
Nilsson provides a method for optimizing limited cases of arrow combinator libraries using GADTs. He
is still bound to the limitations of the amesiac nature of function composition inside the arrow
framework for functional reactive programming, but seem to gain some noticeable gains in performance
especially in microbenchmarks that are modelling the arrow laws.
@End @Section

@Section
  @Title { Conclusion and Further Work }
@Begin
@PP
We have found a way to generalize function composition by separating its
type structure from its semantics. The data structure we suggest is a
GADT with two constructors strongly resembling classical lists, but with a
side-condition that the types must be threaded. The semantics is provided by
an interpretation function that can be provided separately for each first parameter
of the Thrist type constructor.

@PP We have further provided three examples for the usefulness of the thrist data
structure and demonstrated that the ability to take thrists apart and analyse is
a very good arguments for their use. Also, all operations performed on thrists, such
as subdivision, insertion and extension must be performed by algorithms that preserve

We have shown that thrists generalize arrows naturally and monads with
a shallow adaptation layer. 
@LP what other useful @Haskell { p }s in @Haskell { Thrist p a b } exist?
@LP is parametricity in the first parameter useful? I.e.
can we formulate sensible functions on @Haskell { Thrist p a b }, where
p is left universal?
@LP Given certain callback functions, can the Thrist be accompanied with
a generic interpretation function, in the style of @I {Unimo}? Would it be
possible to instrument thrists with a monadic semantics this way?
@End @Section


@Section
  @Title { Acknowledgements }
@Begin
@PP
My special thanks go to Tim Sheard, whose @Omega system served as an
excellent testbed for formulating the ideas expressed in this paper.
The @I { HaL 2 } workshop gave me the opportunity to discuss the connection
between categories and thrists, thanks to Heinrich-Gregor Zirnstein,
for encouragement and to Johan Jeuring for constructive criticism.
Christopher Diggins corrected some of my views on the Cat language and
provided valuable input for the presentation.
@End @Section


@Appendix
@Title { App 1 }
@Begin
@PP

@End @Appendix

