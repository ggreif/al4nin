@SysInclude { report }
@SysInclude { fig }
@SysInclude { diag }
@SysInclude { tbl }
@SysInclude { graph }
@SysInclude { eq }
@SysInclude { haskell }
@Database @FontDef {"db/lm"}
@Database @Reference {"db/acmrefs"}

def @TargetForExtract right output {}

def @IgnoreForOutput right stuff {}

def @Prompt left input right output { { Helvetica Base } @Font { prompt> @Haskell { input } @PP @I { output } } }
def @Omega { {@I {@Sym Omega}}mega }

@Report
  @CoverSheet { No }
  @ColumnNumber { 2 }
  @InitialFont { LMnine Base 9p }
  @DateLine { Yes }
  @Title { Thrists: Dominoes of Data }
  @Author { Gabor Greif }
  @Institution { "gabor@mac.com" }
#  @SectionHeadingFont { Helvetica Bold }
  @AbstractDisplay { Yes }
# @AbstractFormat { @Centre @Title @DP @Body }
@Abstract {
We develop a novel list-like datastructure (which we name @Haskell {Thrist}),
that is able to capture the typing rule of function composition.
Indeed, we show that when @Haskell {Thrist} is parameterized with the function
type constructor @Haskell {(->)} we can provide an interpretation function
which completely emulates the classical function composition @Haskell {(.)}.
Additionally we can perform pattern matching on our @Haskell {Thrist} elements, thus
obtaining the ability to do analysis on them. On the practical side
we develop three new two-parameter GADTs for inclusion into {@Haskell {Thrist}}s.
The first, when accompanied by an appropriate interpreter, directly model the semantics
of the Cat language, while the second caters for a new type of parser combinator libraries.
In our third example we demonstrate the use of {@Haskell {Thrist}}s in state machines.
The @Haskell {Thrist} approach of exposing the intermediate types where the
elements are joined together especially shows its potential in the ability to
stage the interpreter in a type-safe way and only allows for type correct
transformations.
}
//

@Section
@Title { Structure of the Paper }
@Begin
@PP
In the first section we motivate our later introduction of Thrist with well known
examples. In the third section we develop three practial applications of Thrists.
We also present some less useful but entertaining uses. Section four shows
up possible future directions and summarizes open problems. Section five concludes.
@End @Section

@Section
@Title { Introduction }
@Begin
@PP
We are well acquainted with data structures that are parameterized over
data types, as they are a bread-and-butter tool for functional programmers.
For example the @Haskell {List} datatype could be introduced in Haskell
with the following definition:
@PP
@TargetForExtract "check/List"
@ID @Haskell @Begin
data List :: * ~> * where
  Nil :: List a
  Cons :: a -> List a -> List a
@End @Haskell
@PP
We deliberately avoid the traditional syntax of defining the @Haskell {List} datatype,
and use a @I {GADT-style} definition{@FootNote {in a @I {generalized algebraic datatype}
the data constructor is allowed to define a more specific type than the datatype itself }},
because we want to build on this fundament later.
It is enough to say that @Haskell {List} does not impose any constraints on the
contained datatype whatsoever:
@LD {
{Cons 42 (Cons 33 (Cons 5 Nil))} @Prompt
  { Cons 42 (Cons 33 (Cons 5 Nil)) :: List Int }
}

Departing from single-parameter datatypes we focus on two-parameter
datatypes from now on. These are more interesting for our purposes,
because the two parameters can be put in relation to each other.
The most prominent member of this class of types is the arrow type:

@LD {
{ :k (->) } @Prompt
  { (->) :: *0 ~> *0 ~> *0 }
}

Fully saturated, @Haskell {a -> b} signifies the type of all functions that take elements of @Haskell {a} to
elements of @Haskell {b}. Again, @Haskell {a} and @Haskell {b} can be any type, concrete ones will do just like
universally qualified ones:
@LD {
{id} @Prompt
  {<fn> : forall a.a -> a}
}
@RLD {
{ord} @Prompt
  {<primfun to1> : Char -> Int}
}
@LP
Now, functions are a bit more interesting than @Haskell {List}s above, they can be composed!
Interestingly, composition (written as (.)) is again a function:
@LD {
{(.)} @Prompt
  {<fn> : forall a b c.(a -> b) -> (c -> a) -> c -> b}
}
This function signature has several interpretations, but the most common one tells us that
the composition function @Haskell {(.)} takes a function with type @Haskell {a -> b} as its first argument, then
a function with type @Haskell {c -> a} as its second argument, and returns a function of type @Haskell {c -> b}.
Again, @Haskell {a}, @Haskell {b} and @Haskell {c} can be arbitrarily specialized or be left universal.
We can play with our new toy in the following way:

@LD {
{ let locase = chr . ("\\"x -> x + 32) . ord } @Prompt
{ locase }
}
@RLD {
{  locase 'G' } @Prompt
{  'g' : Char }
}
@LP
The type of the composition function constrains the types of its arguments in
a nontrivial way: the range of the second funtion must match with the domain
of the first. (Universal types will always match, monotypes must be equal).
Violating this rule gives a type error:

@LD {
{ ord . ord } @Prompt
{
In the expression: ord
the result type: Char -> Int
was not what was expected: a -> Char
}
}

This crucial property of the composition function will guide our explorations in this
paper.

@BeginSubSections

@SubSection
@Title { Generalizing Function Composition }
@Begin
@PP
While function composition seems to be a cute artifact of mathematics, (where
nevertheless all computable functions can be derived from), this is no reason
for us to stop at this point! First, we observe that function composition is a one-way
street: once two functions are composed, they amalgamate beyond recognition.
There is no way (inside our system) to take them apart again. This is very much
resembling the addition, where @Haskell { (23 + 19) } gives @Haskell {42} and this result has completely
lost all memories of the fact how it was obtained. But can we create a datastructure
that has all properties of function composition, without being amnesiac?
@PP
Indeed we can, and the rest of this section shall explain how.
@PP
Our crucial observation from the introduction was that the types at the ends of the function
arrows must thread up, intuitively @FootNote { we reconcile the conflict between
the function arrow's @Haskell {(->)} direction and the customary
composition @Haskell {g . f} by considering a modified @I {reverse composition} }:

@ID { @Haskell {a ->} @Box @Haskell {b (.) b} @Haskell {-> c} @Sym equivalence @Haskell {a -> c} }

We also observe that the intermediate types do not show up in the end result's type.

Let's simulate these rules as a datatype:

@TargetForExtract "check/Thrist1"
@ID @Haskell @Begin
data Thrist :: * ~> * ~> * where
  Nil :: Thrist a a
  Cons :: (a, b) -> Thrist b c -> Thrist a c
@End @Haskell

The alert reader will have noticed that we have defined a proper GADT,
since the @Haskell {Nil} constructor is only inhabiting the @I diagonal
of the @I {two-dimensional} parameter space.
@PP
We can now duplicate the @I feeling of function composition:

@Haskell operators {Base} { Cons ('g', 103) $ Cons (103, 71) $ Cons (71, 'G') Nil }

Also we have obtained a datatype that is not amnesiac, i.e. it can be
torn apart at any place by pattern matching, though we have to pay
the price that the intermediate types are a bit hard to deal with
(we shall revisit this issue later).
@PP
It appears that we have reached our goal, we can form list-like data where the intermediate
types thread up, we are happy and name our new toy @I Thrist, a portmanteau of thread and list.
@PP
Our joy, however, quickly fades away when we compare our thrist with the composition function.
How can some data of type @Haskell {Thrist a b} be interpreted as an arrow type @Haskell {a -> b}?
If we fail to provide this embedding, we cannot consider thrists being a generalisation of
function composition.
@PP
Not everything is lost, however. Close scrutiny reveals that our usage of
@Haskell {(,)}{@FootNote { pronounced "\"pair\""}},
is the culprit. If we could liberate ourselves from this
premature decision, we could gain back our hope.
@End @SubSection

@SubSection
@Title { The Improved Thrist }
@Begin
@PP
We try all over again, this time abstracting away the pair into an additional parameter:

@TargetForExtract "check/Thrist"
@ID @Haskell @Begin
data Thrist :: (* ~> * ~> *) ~> * ~> * ~> * where
  Nil :: Thrist p a a
  Cons :: p a b -> Thrist p b c -> Thrist p a c
 deriving List(l)
@End @Haskell

All that remains of the pair is the bitter aftertaste
and the letter @Haskell {p} in the definition of @Haskell {Thrist}.
@PP
It looks like we are getting closer now:
@LD {
{ Cons chr (Cons ("\\"x -> x + 32) (Cons ord Nil)) } @Prompt
{ ... : Thrist (->) Char Char }
}
We have created an @I {arrow thrist}!

Immediately we can retry our previous attempt:
@LD {
{ Cons ('g', 103) (Cons (103, 71) (Cons (71, 'G') Nil)) } @Prompt
{  ... : Thrist (,) Char Char }
}
The @I {pair thrist} that caused us some headache before!
@PP
We shall explore some other interesting but sometimes futile
thrists later in the discussion. But now let's put the last missing
piece in place to show that an arrow thrist is strictly more general
than function composition, the @Haskell {runArrowThrist} function:

@ID @Haskell @Begin
runArrowThrist :: Thrist (->) b c -> c -> b
runArrowThrist Nil b = b
runArrowThrist (Cons f r) a = runThrist r (f a)
@End @Haskell


This function now confirms the vague intuition that @Haskell {Nil} plays the r{@Char ocircumflex}le of
the neutral element of the arrow thrist, just like the identity function
plays the r{@Char ocircumflex}le of the neutral element in the monoid of composed functions.
We shall encounter this recurring fact as we proceed to our implementations.
@LP The definition of @Haskell { runArrowThrist } on a @Haskell { Cons } constructor
deserves some attention. We have not yet explicitly mentioned it, but range of
the function @Haskell { f } is existentially qualified, because it does not
appear in the final result of @Haskell { Cons }. This implies a minor complication
when pattern matching: the {@I head} component{@FootNote {or for symmetry reasons the {@I tail} too} }
of a @Haskell { Cons } cannot be
passed to non-local functions, because the existential type would escape.
@PP
@Considerations {
[Question: is every thrist a monoid? "http://en.wikipedia.org/wiki/Monoid"]
}
@PP
Looking back at our progress so far, the analogy of thrists with the game of
dominoes ("http://en.wikipedia.org/wiki/Dominoes") could spring into our minds:
@LP Dominoes are laid out in a valid configuration only, when the stones sharing a common
edge possess the same number of dots next to this edge. Our @Haskell {Nil}
corresponds to an empty board, and @Haskell { Cons } joins two stones with
a common edge. A simple, but important difference to our thrists is that the
dominoes' face numbers do not correspond to the contained @I {value}, but to the
@I type of the contained value: we are playing dominoes at the type level.

@End @SubSection

@EndSubSections

@End @Section

@Section
@Title { Three Practical Thrists }
@Begin
@PP

Now that we have defined the Thrist datatype and gave a sufficiently
generic interface to cover nontrivial cases, time has come to look for
real-world applications. Specifically we shall describe a combinator
library for creating ASTs of the Cat language, a statically typed stack-
oriented language ("http://www.cat-language.com/"), and a parser
combinator library. We shall sketch the use of thrists in transition
arrows of state machines and finally give some curious examples
that may have some practical value.

@BeginSubSections

@SubSection
@Title { Application one: the Cat Thrist }
@Begin
@PP
Like all stack-oriented languages Cat employs a simple idiom of
computation. A rich set of primitives are available for pushing
values on a stack, permuting them and popping them off. Logical
and arithmetic primitives consume portions of the top of the stack
(TOS) and deposit results in their place. Procedures can be defined
as a succession of primitive invocations and procedure calls.
The semantics of procedure calls is defined as the insertion of the
called procedure's contents to the point of the invocation.
@PP
Let's begin with the definition of the Cat datastucture, that will
serve as the first parameter to Thrist. Clearly it should be
parametrized with two types. Naturally we choose the
first type parameter to describe the shape of the stack before
and the second parameter after the Cat primitive has been
executed.

@TargetForExtract "check/Cat"
@ID @Haskell @Begin
data Cat :: * ~> * ~> * where
  Push :: a -> Cat opaque (a, opaque)
  Pop :: Cat (a, opaque) opaque
  Dup :: Cat (a, opaque) (a, (a, opaque))
  Add :: Cat (Int, (Int, opaque)) (Int, opaque)
@End @Haskell

@BeginSubSubSections

@SubSubSection
@Title { First Explorations }
@Begin
@PP
We shall extend our Cat with new primitives as the need arises, but
for now we have enough to perform some experiments.
We have chosen the tuple datatype to represent stack shapes,
but we are free to pick any other sequence-like datatype that
is able to record the type of each element.
The Cat datatype is defined as a GADT, which will guarantee
that only sematically sound programs can be expressed as a
Thrist Cat. We can begin our explorations immediately:
@LD {
{ Cons (Push 19) $ Cons (Push 23) $ Cons Add $ Cons Pop Nil } @Prompt
{ Cons (Push 19) (Cons (Push 23) (Add (Cons Pop (Cons Add (Cons Pop Nil)))) :: Thrist Cat a a }
}
The data we built up can be a representation of a Cat program that
pushes 19 and then 23 on the stack, adds them, keeping only the
result 42 on the stack, and then pops this result off. The inferred type
tells us that there is no netto change in the stack's shape.

@End @SubSubSection


@SubSubSection
@Title { Making Use of @Omega{}'s features }
@Begin
@PP
We shall from now on make use of a feature of the @Omega language
to define custom syntax for datatypes. Our aim is to hide the
Thrist constructors @Haskell { Cons } and @Haskell { Nil } behind a more intuitive fa{@Char ccedilla}ade.
We shall write the above expression as
@LD {
{ [Push 19, Push 23, Add, Pop]l } @Prompt
{ [Push 19, Push 23, Add, Pop]l :: Thrist Cat a a }
}
@Omega's parser and printer perform the conversion to
the internal form when the list-like brackets @Haskell {[]} followed
by the letter "\"l\"" are encountered.
@PP
We can now continue using this terser syntax:
@LD {
{ [Pop, Pop]l } @Prompt
{ [Pop, Pop]l :: Thrist Cat (a, (b, c)) c }
}
The inferred type reflects the function of this Cat fragment,
namely starting out with a stack that has at least two elements
pushed, we end up with those two values removed.
@LP There are invalid Cat programs, for example addition of two
characters:
@LD {
{ [Push 'a', Dup, Add]l } @Prompt
{ the result type: ... was not what was expected: ... }
}
The GADT-based type inference fails, because @Haskell { Add }
expects two integers on the stack, but there are two @Haskell { Char }s available instead.
@End @SubSubSection

@SubSubSection
@Title { Interpreter }
@Begin
@PP
Now it is time to build an interpreter for Thrist Cat, and
thus define its big-step semantics:
@ID @Haskell @Begin
interpret' :: Thrist Cat a b -> a -> b
interpret' []l st = st
interpret' [Push x; rest]l st = interpret' rest (x, st)
interpret' [Pop; rest]l (a, st) = interpret' rest st
interpret' [Dup; rest]l (a, st) = interpret' rest (a, a, st)
interpret' [Add; rest]l (a, b, st) = interpret' rest (a + b, st)
@End @Haskell
It works:

@LD {
{ interpret' [Push 19, Push 23, Add]l () } @Prompt
{ (42, ()) :: (Int, ()) }
}

With this basic functionality in place, we get bolder and define
a primitive with side effect:

@ID @Haskell {
data Cat :: * ~> * ~> * where
  Print :: Cat (a, opaque) opaque
  ...
}

To interpret the @Haskell {Print} primitive we have to restructure
our @Haskell {interpret'} function to wrap the stack into the @Haskell {IO} monad:

@ID @Haskell operators {Base} {
interpret' :: Thrist Cat a b -> IO a -> IO b
interpret' [Print; rest]l st = do
        (a, st') <- st
        putStr $ show a
        interpret' rest st'
  where monad ioM
}
In this function @Haskell { ioM } is globally bound to a value of type @Haskell { Monad Maybe }
containing the monadic @Haskell { return } and @Haskell { bind } functions
for the { @I do-notation }'s perusal{ @FootNote { @Omega's (current) lack of @I { type classes }
necessitates the explicit passing of @Haskell { Monad :: (* ~> *) ~> * } values } }.
In similar spirit we have to rewrite the other cases too:

@ID @Haskell operators {Base} @Begin
interpret' [Pop; rest]l st = do
        (a, st') <- st
        interpret' rest $ return st'
  where monad ioM

interpret' [Push x; rest]l st = do
        interpret' rest $ return (x, st)
  where monad ioM

interpret' [Dup; rest]l st = do
        (a, st') <- st
        interpret' rest $ return (a, a, st')
  where monad ioM

interpret' [Add; rest]l st = do
        (a, b, st') <- st
        interpret' rest $ return (a + b, st')
  where monad ioM
@End @Haskell

Trying out this monadic interpreter gives us:
@LD {
{ interpret' [Push 21, Dup, Add, Print]l (returnIO ()) } @Prompt
{ Executing IO action
@LP 42
@PP () :: IO () }
}

It is a reasonable restriction to Cat programs that they can
be started with any stack shape and they finish with the same
stack unchanged. We can ensure this property by writing
a top-level interpreter function for Cat programs using
@I {rank-2 polymorphism}:

@ID @Haskell operators {Base} @Begin
interpret :: (forall a. Thrist Cat a a) -> IO ()
interpret program = interpret' program $ returnIO ()
@End @Haskell

Obviously this @Haskell {interpret} function is only called for side-effects.
@End @SubSubSection

@SubSubSection
@Title { Extending the Primitives }
@Begin
@PP

Above we have defined an arithmetic primitive in Cat, namely @Haskell { Add }. While possible,
it is not desired to define all (which is potentially a lot) primitives this
way, with their own typing rules, and own clause in the interpreter. Also,
this approach does preclude a very useful notion, called @I { partial application }. In this
example, @Haskell { Add } must always be applied to two elements on the stack.
@PP What we are looking for is a more-or-less generic approach to define
logical and arithmetic operators in Cat, say, using the @Haskell { Prim (+) }
to frob arithmetic addition from the underlying @Omega implementation.

@LD @Heading { Encountering First Problems }
We could introduce @Haskell { Prim } thus:
@ID @Haskell {
  Prim :: (a -> b) -> Cat (a, opaque) (b, opaque)
  ...
}
While this approach can surely be made to work with unary functions,
it is not immediately seen how binary @FootNote { or arbitrary arity functions for that matter }
operators can be formalized in the type-safe way mandated by @Omega{.}
The expectation is that a binary primitive would consume the top @Haskell { n } items from the
stack and produce one item as the result.
@LP We have to reformulate our typing rule to deal with the case that
the type parameter @Haskell { b } is in turn a function arrow. Since @Omega
allows us to decompose the arrow's structure using a type function, we try:
@ID @Haskell {
  Prim :: (a -> b) -> Cat {blowUpBy (a -> b) opaque} ({result b}, opaque)
  ...
}
@Haskell { blowUpBy } @FootNote { see the definition of @Haskell { blowUpBy }
and @Haskell { result } in the Appendix } creates the expected stack shape needed
for fully saturating the primitive, while @Haskell { result } determines the
rightmost type in the function's type.
With these definitions we can observe the correct type inference of our @Haskell { Add }
substitute @Haskell { Prim (+) }:
@LD {
{ Prim (+) } @Prompt
{ Prim <fn> :: Cat (Int, Int, a) (Int, a) }
}

@LD @Heading { More Problems while Interpreting }
Unfortunately we have not mastered everything yet. We remember that
the semantics of our Cat combinators is defined by the interpretation
function. So we are obliged to extend @Haskell { interpret }. We can try thus:

@TODO


@LD @Heading { Using Representation Types to Describe Arities }
The solution is to attach an object of @I {representation type} to every @Haskell { Prim }
combinator, to aid continued interpretation in the multi-arity case.
@LP To this end we need a description of what types are being passed in
stack slots. This description must be a value so that it can be pattern
matched at runtime and it has to provide a constructor for all tractable
datatypes.

@ID @Haskell {
data Tractable :: * ~> * where
  IntT :: Tractable Int
  BoolT :: Tractable Bool
  CharT :: Tractable Char
  PairT :: Tractable a -> Tractable b -> Tractable (a, b)
  ListT :: Tractable a -> Tractable [a]
  ArrT :: Tractable a -> Tractable b -> Tractable (a -> b)
}

provides a way to describe some data types that are built into @Omega{.} Its
first three constructors apply to basic datatypes, while the rest encodes
rules, how compound datatypes can be represented, given tractable ones.
@PP We can proceed by employing this descriptive facility into our @Haskell { Prim }
constructor:

@ID @Haskell {
  Prim :: Tractable b -> (a -> b) -> Cat {blowUpBy (a -> b) opaque} ({result b}, opaque)
  ...
}

The first argument to @Haskell { Prim } is called a @I representation{ @FootNote { technically
these types are called @I { singleton types } and constitue a reflection of the structure
of the type-level objects into the value-world. }}, becase it records the
structure of the function's range's type{ @FootNote { It suffices to describe the range, because
the domain's type is easily handled without a representation. } }.
@LP We can reproduce our previous @Haskell { Add } primitive now:

@LD {
{ Prim (ArrT IntT IntT) (+) } @Prompt
{ Prim (ArrT IntT IntT) (+) <fn> :: Cat (Int, Int, a) (Int, a) }
}

@LD @Heading { Interpreting Primitives }
We finally have all ingredients together to embark on putting down the @Haskell { interpret }
case on @Haskell { Prim }. The key idea is here to pattern match on the representation value in order
to incrementally saturate the @Omega function present in the primitive:

@TODO


@End @SubSubSection

@SubSubSection
@Title { Staging the Interpreter }
@Begin
@PP
A well-known technique to turn an interpreter into a compiler
is staging. The compile function takes a Thrist Cat into
a function of the metalanguage, that when executed causes the
same effect as the interpretation of the program itself. Naturally,
the compiled program is expected to run faster, since the interpretative
overhead is already removed.

We demonstrate the technique for a selection of the Cat primitives
only.

@ID @Haskell operators {Base} @Begin
compile' :: Thrist Cat a b -> Code (IO a -> IO b)
compile' [Print; rest]l = [| \st -> do
        (a, st') <- st
        putStr $ show a
        $(compile' rest) $ return st'
    where monad ioM |]
@End @Haskell

[TODO: Push, etc.]

@End @SubSubSection

@SubSubSection
@Title { Optimization }
@Begin
@PP
The fact that Cat programs are represented as data in the metalanguage
that is amenable to analysis by pattern matching, we can write an optimization function
that performs several code optimizations on a program, such as head and tail merging
of conditionals, value folding, inlining etc. Because the Cat thrist does not admit wrongly
typed Cat programs and the optimization function takes Thrist Cat to Thrist Cat,
all optimizations must be type preserving.
@End @SubSubSection

@SubSubSection
@Title { Generalization }
@Begin
@PP
The language Cat is intended as an intermediate language produced by
front-end compilers and consumed by back-ends that target stack based
virtual machines like JVM and CIL. It is advisable to generalize Cat in a way
that Pop gets a count parameter that tells how many elements are to be
popped of the stack. Also instead of Swap it would be beneficial to have
a Permute primitive that subsumes all variants of stack shuffling operations,
allowing us to get rid of Swap and friends. All these parametrized primitives
would have one problem in common, namely that the stack shape would
vary depending on the  value of the parameter(s), requiring dependent
types to define them. Fortunately @Omega provides a device that is approaching
the power of dependent types, singleton types and type-level functions.

Here is a sketch of PopN:

@ID @Haskell {
  PopN :: Nat' (S n) -> Cat {blow (S n) s} s
}
It uses the type-level function blow to add the
necessary number of universal type variables
to the initial stack's shape:

@ID @Haskell {
blow :: Nat ~> *0 ~> *0
{blow Z s} = s
{blow (S n) s} = (t, {blow n s})
}
The interpreter can be written thus:

@ID @Haskell {
interpret [PopN (S n); rest]l st -> do
        (_, st') <- st
        case n of
        0v -> interpret' rest st'
        _ -> interpret' [PopN n; rest]l st'
}

@End @SubSubSection

@EndSubSections

@End @SubSection


@SubSection
@Title { Application two: a GADT-based Parse Thrist }
@Begin
@PP
Traditional monadic parser combinator libraries (like Parsec) suffer from the
same problem like the composition operator: they compose easily
but cannot be dissected and analysed, or translated to other
representations. We proceed similarly to the @Haskell { Thist (->) } and @Haskell { Thrist Cat } to
create a parsing combinator library that is representation agnostic, i.e.
can be interpreted or compiled and analysed in any reasonable way.



@BeginSubSubSections

@SubSubSection
@Title { Envisioning Parsing }
@Begin
@PP

But first let's be clear about what we aim at. We demonstrate the process of
parsing by the example of a lexer with semantic evaluation. Our tokens
are the various literal numerals like they occur in the C language:
@ID @F {0xCafeBabe 0XE0UL 123456L}
These are the steps we wish to proceed on the second token:
@List
  style { num) }
  start { 0 }
@ListItem { token as read from character stream:
@ID @F 0XE0UL
}
@ListItem { We match the @F "0X" prefix:
@ID @F {{@Box 0X}E0UL}
}
@ListItem { We expect zero or more hexadecimal characters (we come to the explanation of why zero, later)
@ID @F {{@Box 0X}{@Box E0}UL}
}
@ListItem { We fold the hex string found to a decimal integer
@ID @F {{@Box 0X}{@CurveBox {@Box E0}}UL}
(at this step we would fail if the string had been empty)
}
@ListItem { We look for an optional signedness hint
@ID @F {{@Box 0X}{@CurveBox {@Box E0}}{@Box U}L}
}
@ListItem { We look for an optional storage size hint
@ID @F {{@Box 0X}{@CurveBox {@Box E0}}{@Box U}{@Box L}}
}
@ListItem { We encapsulate the distilled information into a token datatype
@ID @F @Box {{@Box 0X}{@CurveBox {@Box E0}}{@Box U}{@Box L}}
}
@EndList
@End @SubSubSection

@SubSubSection
@Title { Realization }
@Begin
@PP

To be able to compose these operations we define the GADT Parse:

@ID @Haskell {
data Parse :: * ~> * ~> * where
  Epsilon :: Parse [a] ([b], [a])       -- always match, return everything
  Atom :: Char -> Parse Char Char       -- exact match
  Sure :: (a -> b) -> Parse a b         -- always match and convert
  Try :: (a -> Maybe b) -> Parse a b    -- pipeline stops if no match
  Rep1 :: Parse a b -> Parse [a] ([b], [a])          -- consume as many as matches found, return rest
  Rep :: Parse [a] (b, [a]) -> Parse [a] ([b], [a])  -- consume as many as matches, return rest
  Group :: [Parse a b] -> Parse [a] ([b], [a])       -- all must match, return rest
  CataPlus :: ([a] -> b) -> Parse ([a], c) (b, c)    -- collapse one or more elements
  Par :: Parse a b -> Parse c d -> Parse (a, c) (b, d)
  Wrap :: Thrist Parse a b -> Parse a b
}

The datatype @Haskell { Parse a b } represents a parser that consumes data of type @Haskell { a }
and if a match is found produces data of type @Haskell { b }.

@DashList
@ListItem {  @Haskell {(Atom 'X')} matches only the capital @Haskell {'X'} character }
@ListItem {  @Haskell {Epsilon} matches a zero-size prefix of a list of @Haskell {as} and returns an empty list of @Haskell {bs} along with the unconsumed rest of @Haskell {as} }
@ListItem {  @Haskell {(Sure ord)} alway matches, consuming a @Haskell {Char} and returning its @Haskell {Int} ASCII value }
@ListItem {  @Haskell {(Try hexdigit)} matches only if a character is a hexadecimal one and returns its hex value, fails otherwise }
@ListItem {  @Haskell {(Rep1 (Atom 'X'))} matches as many capital @Haskell {'X'}s as possible and returns a pair consisting the matched and unconsumed portions }
@ListItem {  @Haskell {(Group [Atom 'a', Atom 'b'])} matches only a prefix @Haskell {"\"ab\""} in the input, returning it in a pair along with the unconsumed portion or fails otherwise }
@ListItem {  @Haskell {(CataPlus foldDec)} consumes a pair of a list of digits and some other data, if the list is empty it fails, otherwise it folds the sequence to a number, then returns the pair of this number and the other data, which remains unchanged }
@EndList

In the above descriptions we only suggest a possible semantics, the data of type Parse does not mandate it in any way. So when we talked about "\"returns such-and-such\"" then this is just an intention.

The end result of parsing a token will amount to

@ID @Haskell {
data Token =
  Number Int Bool Bool
  | ...
}
So we expect that our parser that produces Tokens to have a type Thrist Parse [Char] ([Token], [Char]).

@End @SubSubSection

@SubSubSection
@Title { Using the Combinators }
@Begin
@PP
How can we use our combinators to describe the parsing steps 0) to 6) above?
@BulletList

@ListItem { First, we use
@Haskell operators {Base} {Group [Atom '0', Atom 'X']}
to match the prefix of the string @Haskell {"0XE0UL"} and
produce @Haskell {("0X", "E0UL") :: ([Char], [Char])}.
}

@ListItem { Then we can discard the prefix because we know we have to do base 16 conversion later,
we can use @Haskell {Sure snd}
to do this obtaining @Haskell {"E0UL" :: [Char]}.
}

@ListItem { Then @Haskell operators {Base} {Rep1 $ Try hexdigit}
will split off two more characters, converting them to hex values on the way, we obtain @Haskell { ([14, 0], "UL") :: ([Int], [Char]) }.
}

@ListItem { We cannot discard either component, so we proceed in parallel with
@LD @Haskell operators {Base} {Par (CataPlus foldHex)
       (Wrap [Rep1 $ Atom 'U', Par (Sure id) (Rep1 $ Atom 'L')]l)
}
where the first component produces 224, and the second will proceed by splitting off any @Haskell { 'U' } and then
splitting off any @Haskell { 'L' }, producing a triple @Haskell { ("U", ("L", "")) }.
At this stage we have @Haskell {(224, ("U", ("L", ""))) :: (Int, ([Char], ([Char], [Char])))}.
}

@ListItem { Finally, we feed this into @Haskell {Try numberToken}
that verifies the correct usage of 'U's and 'L's, and creates a pair
@Haskell {(Number 224 True True, "") :: (Token, [Char])}
consisting of the parsed token and the rest of the input.
}
@EndList

Putting this all together we can write
@ID @Haskell operators {Base} {
signedSized = Wrap [Rep1 $ Atom 'U', Par (Sure id) (Rep1 $ Atom 'L')]l

hexToken = Wrap [Group [Atom '0', Atom 'X']
  , Sure snd
  , Rep1 $ Try hexdigit
  , Par (CataPlus foldHex) signedSized
  , Try numberToken
  ]l

tokens = Rep hexToken
}

Of course there are some pitfalls here but the principle is clear:
@DashList
   @ListItem { The interesting prefix is split off the rest, }
   @ListItem { if the prefix is semantically important it gets condensed to a more appropriate form or else discarded, }
   @ListItem { parallel processing is used if both components of an input pair are relevant. }
   @ListItem { As the execution of the trist proceeds the incrementally more of the token are analysed, condensed and converted. }
@EndList

@TargetForExtract "check/Machine"
@Figure
    @Tag { machine }
    @Caption { State machine fragment }
@Diag # vstrut { yes } treehsep { 1c }
      outline { curvebox }
      nodelabelfont { Slope -2p }
      linklabelformat { "/"@Body"/" } 
{



    # @HTree { @Box Lout @FirstSub arrow { yes } @Box PostScript }

@Tbl
    aformat { @Cell indent { ctr } iv { ctr } A | @Cell indent { ctr } iv { ctr } B }
    bformat { @Cell indent { ctr } width { 3c } height { 1c } A | @Cell indent { ctr } height { 1c } B | @Cell indent { ctr } height { 1c } C }
    marginhorizontal { 0.5c }
    marginvertical { 0.25c }
{
@Rowa
    A { NW:: @Node NorthWest }
    B { N:: @Node North }
@Rowa
    A { W:: @Node West }
    B { M:: @Node Mid }
@Rowb
    B { S:: @Node South }
    C { SE:: @Node SouthEast }
}

||1f { Base -2p } @Font @Tbl
    aformat { @Cell A }
{
@Rowa
    A { @Haskell @Begin
NorthWest :: State GateClosed SecondaryEnabled (H Idle Idle')
        @End @Haskell }
@Rowa
    A { @Haskell @Begin
North :: State GateClosed SecondaryEnabled (H Idle Idle')
        @End @Haskell }
@Rowa
    A { @Haskell @Begin
West :: State GateClosed SecondaryEnabled (H Idle NeedAck)
        @End @Haskell }
@Rowa
    A { @Haskell @Begin
Mid :: State GateClosed SecondaryBlocked (H Idle NeedAck)
        @End @Haskell }
@Rowa
    A { @Haskell @Begin
South :: State GateClosed SecondaryBlocked (H Idle Idle')
        @End @Haskell }
@Rowa
    A { @Haskell @Begin
SouthEast :: State GateOpen SecondaryBlocked (H Idle Idle')
        @End @Haskell }
}


//
@Arrow from { NW } to { N } ylabel { req } ylabelctr { no }
@Arrow from { N } to { M } ylabel { plug } ylabelctr { no }
@Arrow from { NW } to { W } ylabel { plug } ylabelctr { no }
@Arrow from { W } to { M } ylabel { req } ylabelctr { no }
@Arrow from { W } to { S } ylabel { ack }
@Arrow from { M } to { SE } ylabel { ack }
@Arrow from { S } to { SE } ylabel { req } ylabelctr { no }
}




@End @SubSubSection

@SubSubSection
@Title { Defining the Semantics by Interpretation }
@Begin
@PP
We provide the parse function for the Rep constructor as an example:

@LD @Haskell {
parse :: Thrist Parse a b -> a -> Maybe b

parse [Rep p; r]l as = parse r (parseRep [p]l as) where
      parseRep :: Thrist Parse [a] (b, [a]) -> [a] -> ([b], [a])
      parseRep _ [] = ([], [])
      parseRep p as = case parse p as of
                      Nothing -> ([], as)
                      Just (b, as') -> (b:bs, rest)
                          where (bs, rest) = parseRep p as'
}

@End @SubSubSection

@SubSubSection
@Title { Compilation }
@Begin
@PP
Similarly to the Thrist Cat we can compile our parser combinators to
a more efficient algorithm by removing the interpretative overhead.

@End @SubSubSection

@SubSubSection
@Title { Analysis }
@Begin
@PP
We can run various analyses on our parsers, to ensure that the grammar is unambiguous, for example.

@End @SubSubSection

@SubSubSection
@Title { Outlook }
@Begin
@PP
Many interesting other combinators can be defined, my repository contains also
@LD @Haskell {
  Seq :: Parse [a] (b, [a]) -> Parse [a] (c, [a]) -> Parse [a] ((b, c), [a]) -- parse front first then second
  Seq1 :: Parse a b -> Parse a c -> Parse [a] ((b, c), [a]) -- same, but with single-elem first and second
  ButNot1 :: Parse a b -> Parse a b -> Parse a b     -- match first and expect second to fail
  UpTo :: Parse [a] (b, [a]) -> Parse [a] (c, [a]) -> Parse [a] ((b, c), [a]) -- scan for c then match b
}
etc.

I think working together with a parsing expert could result in a minimal set of combinators that
allow parsing a great variety of grammars and optimization and compilation methods that make
the parsing process *fast*.
@End @SubSubSection

@EndSubSubSections

@End @SubSection


@SubSection
@Title { Application three: Actions on State Machine Transitions }
@Begin
@PP
One popular use of metaprogramming tools is generating code for legacy
systems, especially when the high-level language's whole feature set is
too heavy for the application, such as in embedded systems with significant
resource limitations. We wish a system where very strong guarantees are maintained
in the model by resorting to typeful data representation and nevertheless
preserve the ability to convert our model into a lower-level representation
that is feasible for the target system.

@BeginSubSubSections


@SubSubSection
@Title { The Transition System }
@Begin
@PP
Figure @NumberOf { machine } depicts a fragment of a state machine intended to handle
@I { request"/"acknowledge } type handshake with an identical remote instance
of itself. The two instances are communicating solely by message passing
and originally both inhabit the @I NorthWest state. The intention is that the
two machines control the ends of a unidirectional communication channel
that is {@I protected}, i.e. two wires exist, carrying a data stream A on the
first wire{ @FootNote {the second wire can either carry the same data as A (to increase redundancy),
or the two wires could jointly carry stream A (to increase bandwidth)} },
and when the first wire does not carry data, the second wire can
be utilized to carry a lower-priority data stream B. The typical use-case
is the premium customer paying for A and the bulk customer paying significantly
less for B. There is an extra twist however: it is forbidden for the data stream A
to reach the sink of data stream B, even for very short time periods. This invariant
calls for the request"/"acknowledge handshake, and the transient states on the way to
the @I SouthEast state mirror this protocol.

@End @SubSubSection



@SubSubSection
@Title { Typed States }
@Begin
@PP
We intend to equip the states with an orthogonal system of properties
(which we call {@I facets}), and hope to assemble transition arrows
from a toolbox of elementary actions which deal with a minimal number
of facets each.
To formally introduce the facets, we employ another @Omega feature,
namely @I { user-defined kinds }, whose alternatives can be used to
parameterise the @Haskell { State } datatype:
@ID @Haskell @Begin
kind Gate = GateClosed | GateOpen
kind Secondary = SecondaryEnabled | SecondaryBlocked
kind Handshake = Idle | NeedAck | Requested

data State :: Gate ~> Secondary ~> Handshake ~> * where
  State :: [Transition g s h] -> State g s h
@End @Haskell

On its right side, figure @NumberOf { machine } shows
the states along with the facets and
the labeling of the transition lists the elementary actions needed
to ensure the working of the handshaking protocol.
@End @SubSubSection

@SubSubSection
@Title { Action Thrists }
@Begin
@PP
We can implement the elementary actions as a GADT:

@ID @Haskell @Begin
data Action :: Gate ~> Secondary ~> Handshake ~> * where
  RequestExclusive :: Action (a, b, Idle) (a, b, NeedAck)
  AckExclusive :: Action (a, b, Requested) (a, b, Idle)
  OpenGate :: Action (GateClosed, SecondaryBlocked, c) (GateOpen, SecondaryBlocked, c)
  BlockSecondary :: Action (a, SecondaryEnabled, c) (a, SecondaryBlocked, c)
  -- ...
@End @Haskell

Then state transitions would correspond to @Haskell { Thrist Action }s that
originate from a state:
@ID @Haskell @Begin
data Transition :: Gate ~> Secondary ~> Handshake ~> * where
  From :: State g' s' h' -> Thrist Action (g', s', h') (g, s, h) -> Transition g s h
@End @Haskell

For instance the @Haskell { South } state could be defined thus:
@ID @Haskell @Begin
South = State [From West [OpenGate]l]
@End @Haskell

@PP
What do we gain with such a declarative description of the state machine at
hand?
@LP
@DashList
   @ListItem { First, given a fine-grained encoding of the protocol's and business logic's
encoding in the state facets, the type system will take care of checking that
all necessary elementary actions are mentioned in the transition's action thrist.
This can be an important assurance in case of great statemachines with a complicated
semantic model. Especially for communicating state machines, as in our example,
the administrative states arising as a result of the handshaking protocol
can be daunting. Getting the transition actions right between all these states
is an error prone task and help from the type system highly welcome. }
   @ListItem { Second, the possibility to pattern-match on the actions that form transitions
it is possible to enumerate all possible admissible configurations of the communicating
state machines and use proof techniques to ensure that the principal invariant of
the system is met{@FootNote { Highlighting this verification aspect is beyond the scope ot this paper } }. }
@EndList

@End @SubSubSection


@EndSubSections

@End @SubSection



@EndSubSections

@End @Section





@Section
  @Title { Exotic Uses }
@Begin
@PP
We have already seen @Haskell { Thrist (,) } and @Haskell { Thrist (->) } in the introduction.
But several more common two-parameter datatypes exist that @Haskell { Thrist } can be parametrized with,
e.g. @I Either{@FootNote { in @Omega named as @Haskell { (+) } }}, @Haskell { Equal } and so on.
In this section we analyse the formal requirements for inclusion into the @Haskell { Thrist } framework,
constructing adapters as needed, and suggest possible uses.

@BeginSubSections

@SubSection
  @Title { Equal Thrist }
@Begin
@PP
In @Omega the @Haskell { Equal } datatype has two parameters, and is used to
track type equality internally. The @I { Curry-Howard correspondence } is employed
to prove propositions encoded in the types of functions, and the resulting @Haskell { Equal }
types can be introduced by @I { theorem declarations } into the type-checker's
rewrite engine. Typical and useful instantiations of @Haskell { Equal } arise in connection
with type fucntions, e.g. @Haskell { Equal {plus a b} {plus b a} } which is a manifestation
of the @Haskell { plus } type function's commutativity.
@LP When we assert @Haskell { trans :: Thrist Equal a a } and @Haskell { trans } is a non-empty
thrist, then @Haskell { trans } can be interpreted as a transitivity proof:
@TODO

Modelling transitivity.

@PP One could go a step farther and consider a (=>){@FootNote {imaginary @Omega operator} }
relation as a binary datatype, with constructors that encode the implication.
Then @Haskell { circ :: Thrist (=>) a a } could encode circular implications, equating
all intermediate types (propositions).

@PP On a speculative note, one could come up with a proof algebra system that has types of
the form @Haskell { Equal (Equal a b) (Equal c d) } in which the outer @Haskell { Equal }
would signify equivalence of propositions.
@LP Then
@ID @Haskell {
data Proof
  And :: ...
  Impl :: ...
  etc.
}
could serve as a way to formulate proofs

@End @SubSection

@SubSection
  @Title { Connection to Arrows and Monads }
@Begin
@PP
Since arrows in the Haskell world also originated from the generalization of function
composition it is helpful to give a comparison of the @Haskell { Arrow } @I { type class } in Haskell and
our Thrist datastructure. Obviously any instance of the Haskell type class @Haskell { Arrow } can
be expressed as a thrist. We have to accompany the @Haskell { Thrist Arrow } with an interpretation
function that is rather canonic, and will be given in the Appendix. This semantics obviously
guarantees the arrow laws @Cite { $hughes00.arrows }. On the other hand thrists are not always
easily fitted in an arrow. It is the @Haskell { arr } instance method that is problematic
to provide. Thrists just serve as a container and do not carry a semantics, while @Haskell { arr }
mandates a function argument for the method @Haskell { arr }.
@Considerations { a value of type @Haskell { Thrist Arrow } corresponds to the @F { do ... proc ... } syntactic sugar expression in Haskell @Cite { $paterson01.notation }}
@PP
Nilsson @Cite { $nilsson05.frp } embarks on optimization of a GADT-based @Haskell { Arrow } library,
but he only considers the identity function as a special case. He observes a substantial
speedup in microbenchmarks when the optimizer is able to discover and short-circuit
the identity arrow. In @Haskell { ParseThrist } the identity can be written in several ways,
e.g. as @Haskell { Wrap Nil } or as @Haskell { Sure id }. When interpreting, there is probably no
significant win in using the former, when compiling to @Haskell { Code } the underlying
metaprogramming system in @Omega presumably possesses all the information to recover
the identity function from the @Omega interpreter's internals. In case of
translation to a different programming system every function inside of @Haskell { Try } and @Haskell { Sure }
constructors would need auxiliary denotation anyway, and could be optimized
either on export or inside of the external system itself.
@PP
Monads can also be regarded as a specialization to arrows, so we expect that @Haskell { Thrist (Monad' T) }
can be canonically derived. Here @Haskell { Monad' T a b } represents the type of a monadic actions
either starting afresh and resulting a monadic value @Haskell { T b } or representing a Kleisli arrow
@Haskell { a -> T b }.
@LP We can define the adapter @Haskell { Monad' } to have three parameters, the first fixing the @Haskell { Monad }
and the last two to accomodate for the @Haskell { Thrist } interface:
@TODO
@ID @Haskell {
data Monad' :: (* ~> *) ~> * ~> * ~> * where
  Feed :: m b -> Monad' m a b
  Digest :: (a -> m b) -> Monad' m a b
}
@PP
@Considerations { a value of type @Haskell { Thrist (Monad' T) } corresponds to the @F { do ... } syntactic sugar expression in Haskell }
@Considerations { Unimo? for ensuring that the interpreter obeys monadic semantics,
 in an Appendix: use Unimo to constuct an @Omega Monad' -> Monad function, hmm this is not correct, unimo :: ??? -> Monad } 
@Considerations { a word about Unimo: does compilation of the unimo value (staging) give the performance back? probably not,
the values are included into the data structure, each monadic "do{}" needs to be compiled. In our context the thrists (Parser)
do not contain "external" values, so no recompilation is necessary. }
@Considerations { Comonads?, see paper @Cite { $heunenjacobs.monoid },
Uustalu"&"Vene:The Essence of Dataflow Programming @Cite { $uustaluvene05.dataflow } }
@Considerations { since thrists do not provide a binding construct like the do-notation
one has to resort to point-free passing of intermediate values (i.e. returning tuples) }
@Considerations { Control.Applicative ? }
@End @SubSection


@SubSection
  @Title { Connection to Categories }
@Begin
@PP
The type-threaded nature of the Thrist datatype is the distinguishing feature of @I { free categories } too. In the Appendix
we supply an @Haskell { appendThrist } function that can be regarded as the inner multiplication (concatenation)
operation in the free category. {@Omega}'s user-defined kind definition allows for defining categories (with countable
object set) as non-inhabited types.

encoding free categories as Thrists
@LP every Thrist gives rise to a category?
@LP RevThrist is the opposite category?
@LP commutative diagrams?
@LP limits?
@End @SubSection


@EndSubSections
@End @Section


@Section
  @Title { Other Work }
@Begin
@PP
Chuan-kai Lin's @I { Unimo } framework @Cite { $lin06.unimo } is an attempt to describe monads operationally
by interpreting a datastructure that describes the monad. By the fact that the interpreter
is proven to satisfy the monadic laws, a guarantee is given that the monadic semantics
is fulfilled, regardless what callback functions the monad's creator supplies. GADTs appear in
his work only as the datatypes modelling the @I { effect basis } of monads, while they are not needed
for the general case.
@PP
Another example of the rekindled interest in modelling side-effecting computations in a purely functional
manner is given by the Haskell Workshop paper of Swierstra et al. @Cite { $swierstra07.beast }, which demonstrates
another use of the @I { free monad }, a data structure built up as an ADT. The result can be examined intensionally
by pattern matching, in a similar fashion like our thrists can be taken apart by the semantics functions.
@PP
Chris Heunen and Bart Jacobs' work @Cite { $heunenjacobs.monoid } on the connection of Arrows and Monads
and their category theoretical formalisation is of relevance because it reveals the mathematical
structure behind these constructs.
Arrows appeared in the general mindset as a pragmatic approach to deal with a certain class of parsers
@Cite { $hughes00.arrows } that did not fit into the monadic framework.
Nilsson provides a method for optimizing limited cases of arrow combinator libraries using GADTs. He
is still bound to the limitations of the amesiac nature of function composition inside the arrow
framework for functional reactive programming, but seem to gain some noticeable gains in performance
especially in microbenchmarks that are modelling the arrow laws.
@End @Section

@Section
  @Title { Conclusion and Further Work }
@Begin
@PP
We have found a way to generalize function composition by separating its
type structure from its semantics. The data structure we suggest is a
GADT with two constructors strongly resembling classical lists, but with a
side-condition that the types must be threaded. The semantics is provided by
an interpretation function that can be provided separately for each first parameter
of the Thrist type constructor.

@PP We have further provided three examples for the usefulness of the thrist data
structure and demonstrated that the ability to take thrists apart and analyse is
a very good arguments for their use. Also, all operations performed on thrists, such
as subdivision, insertion and extension must be performed by algorithms that preserve
the strong typing constraints that are imposed by the @Haskell { Thrist } data structure's
typing rule. For this to work it is crucial that @Haskell { Thrist } is defined to be
a generalized algebraic datatype (GADT).
@PP We have further shown that thrists generalize arrows naturally and monads with
a shallow adaptation layer. Free categories can be modelled as thrists and we conjecture
that computationally relevant categories can be fitted into the @Haskell { Thrist }
framework.
@PP Last, but not least, we could successfully exploit {@Omega}'s extensible syntax
to present thrists in a uniform and aestetical way, well alike {@I Haskell}'s syntax
for lists, with the same ease of pattern matching and construction.
@PP
Although the above provides sufficient evidence of the usefulness of thrists, there
is still plenty to find out.
@LP what other useful @Haskell { p }s in @Haskell { Thrist p a b } exist?
Since the @Haskell { a } and @Haskell { b } parameters can encode
propositions, the @Haskell { Thrist } approach can convey the evolution
of abstract properties, e.g. the adherence to the SSA form @Cite {appel}.
Modern compiler architectures{ @FootNote { GCC @Cite {gcc} and LLVM @Cite {llvm} being notable representants } }
tend to favor this formalism for internal representation of imperative programs.
Explicitly tracking def-use information paired with annotation preserving
transformations might pave the way to certified compilers, but apperars to
be a challenging task.
@LP LLVM has a @I getelementpointer instruction, which allows to do offset calculations
into deeply nested data structures. The decent from the encompassing pointer, array or
structure type can be conveniently encoded as a thrist, where the underlying GADT
provides constructors for dereferencing of pointers, picking of array elements
and skipping over (resp. selecting) of structure members. This thrist can then
easily converted into the sequence of integers that represents the intended
datastructure part in the getelementpointer instruction.
@LP is parametricity in the first parameter useful? I.e.
can we formulate sensible functions on @Haskell { Thrist p a b }, where
p is left universal?
@LP Given certain callback functions, can the Thrist be accompanied with
a generic interpretation function, in the style of @I {Unimo}? Would it be
possible to instrument thrists with a monadic semantics this way?
@LP Folds on thrists. Hard because types vary. Existentials? Folds are very important
for lists, so we need them.
@LP Syntactical questions: can "\"do\"" (monadic) or "\"proc\" ... \"do\"" (arrow{
@FootNote { arrow syntax is available in certain Haskell implementatons, but not in @Omega}})
syntax be used for more convenient construction of thrists than with the @Haskell { [a, b; r]l }
notation?
@LP More generalization, though not very important for demonstration, generalizing the
Thrist type signature to accept the last two parameters from any level of the @I { sort hierarchy }
seems useful. Parity in generality at least with the built-in @Haskell { Equal } type seems
desirable{ @FootNote { in @Omega its type signature is
@Haskell { Equal :: level b.forall (a::*(1 + b)).a ~> a ~> *0 } } }, but even
different levels for the second and third parameters are conceivable.
@End @Section


@Section
  @Title { Acknowledgements }
@Begin
@PP
My special thanks go to Tim Sheard, whose @Omega system served as an
excellent testbed for formulating the ideas expressed in this paper.
The @I { HaL 2 } workshop gave me the opportunity to discuss the connection
between categories and thrists, thanks to Heinrich-Gregor Zirnstein,
for encouragement and to Johan Jeuring for constructive criticism.
Christopher Diggins corrected some of my views on the Cat language and
provided valuable input for the presentation.
@End @Section


@Appendix
  @Title { Useful Functions on Thrists }
@Begin
@PP
Following functions are parametric in the thrist type, i.e.
in the first type parameter to the thrist. Thus they are universal.

@BeginSubAppendices

@SubAppendix
  @Title { Extending Thrists }
@Begin
@LD @Haskell {
extendThrist :: forall (a :: *1) (b :: a ~> a ~> *0) (c :: a) (d :: a) (e :: a).
                Thrist b c d ->
                b d e ->
                Thrist b c e

extendThrist []l a = [a]l
extendThrist [b; r]l a = [b; extendThrist r a]l
}
@End @SubAppendix

@SubAppendix
  @Title { Appending Thrists }
@Begin
@LD @Haskell {
appendThrist :: forall (a :: *1) (b :: a ~> a ~> *0) (c :: a) (d :: a) (e :: a).
                Thrist b c d ->
                Thrist b d e ->
                Thrist b c e

appendThrist []l a = a
appendThrist [b; r]l a = [b; appendThrist r a]l
}
@End @SubAppendix

@SubAppendix
  @Title { Flattening Thrists }
@Begin
@LD @Haskell {
flattenThrist :: Thrist (Thrist k) a b -> Thrist k a b

flattenThrist []l = []l
flattenThrist [a; as]l = appendThrist a $ flattenThrist as
}
@End @SubAppendix

@SubAppendix
  @Title { Instrumenting Thrists }
@Begin
@PP
It might be useful to wrap each thrist member with
a special instrumentation, e.g. for tracing (tracepoints)
or other ways of debugging.
@LP Following function (using rank-2 polymorphism) accomplishes this.
@LD @Haskell {
intersperseThrist :: (forall (x :: *). k x x) -> Thrist k a b -> Thrist k a b

intersperseThrist i []l = [i]l
intersperseThrist i [a; as]l = [i, a; intersperseThrist i as]l
}
@End @SubAppendix

@EndSubAppendices


@End @Appendix

@Appendix
  @Title { A Complete Cat Example: @I fak }
@Begin
@PP
@TargetForExtract "check/CatFak"
@IgnoreForOutput @Haskell @Begin
import "LangPrelude.prg"
data Thrist :: (* ~> * ~> *) ~> * ~> * ~> * where
  Nil :: Thrist p a a
  Cons :: p a b -> Thrist p b c -> Thrist p a c
 deriving List(l) 
@End @Haskell

@LD @Haskell @Begin
-- type functions for creating universals
blowUpBy :: * ~> * ~> *
{blowUpBy (a -> b) s} = (a, {blowUpBy b s})
{blowUpBy Int s} = s
{blowUpBy Bool s} = s

-- type functions for analysing function arrows
range :: * ~> *
{range (c -> d)} = {range d}
{range Int} = Int
{range Bool} = Bool

-- the type universe a Cat program can operate on
data Tractable :: * ~> * where
  IntT :: Tractable Int
  BoolT :: Tractable Bool
  ArrT :: Tractable a -> Tractable b -> Tractable (a -> b)

-- the Cat datatype, language primitives and typing rules
data Cat :: * ~> * ~> * where
  Push :: a -> Cat opaque (a, opaque)
  Pop :: Cat (a, opaque) opaque
  Dup :: Cat (a, opaque) (a, (a, opaque))
  Prim :: Tractable b -> (a -> b) -> Cat {blowUpBy (a -> b) opaque} ({range b}, opaque)
  Block :: Thrist Cat b c -> Cat a (Cat b c, opaque)
  Apply :: Cat (Cat b c, b) c
  If :: Cat (Cat s t, Cat s t, Bool, s) t
  Print :: Cat (a, opaque) opaque

-- some abbreviations
intint = ArrT IntT IntT
intbool = ArrT IntT BoolT

minus = Prim intint (-)
times = Prim intint (*)
equals = Prim intbool (==)

-- the fak program
fak :: Thrist Cat (Int, opaque) (Int, opaque)
fak = [Dup, Push 0, equals,
              Block [Pop, Push 1]l,
              Block [Dup, Dup, Push 1, minus, Block fak, Apply, times]l,
            If]l

usecase = [Push 42, Block fak, Apply, Print]l

compile' :: Thrist Cat a b -> Code (IO a -> IO b)
compile' [Print; rest]l =
   [| \st -> let monad ioM in do
        (a, st') <- st
        putStr $ show a
        $(compile' rest) $ return st' |]

compile' [Pop; rest]l =
   [| \st -> let monad ioM in do
        (_, st') <- st
        $(compile' rest) $ return st' |]

@End @Haskell
@End @Appendix
