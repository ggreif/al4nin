{-
 * Copyright (c) 2010 Gabor Greif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 -}

-- Implement the PTS-like plane
-- of PIs and lambdas (\ and /\), etc.
-- Please refer to
--  http://www.cedar-forest.org/forest/papers/journals-publications/jfp6-2.ps
-- (esp. p. 4, item 4. "Higher degrees").
--
-- There are still many limitations, but I think
-- the major obstacles are solved,
-- moreover categorizers must admit dependent types.

import "LangPrelude.prg"

-- walks in the lambda plane

data Payload :: *1 where
  None :: Payload
  Charge :: Nat ~> Nat ~> Payload ~> Payload
 deriving Record(p)

--                  v-- dimensionality
--           v-- stratum
data Walk :: Nat ~> Nat ~> Payload ~> *1 where
  Origin :: Walk 0t 0t None
  North :: Walk n 0t None ~> Walk (1+n)t 0t None
  Pair :: Walk k l p ~> Walk n m None ~> Walk n m {k=l;p}p
  SE :: Walk (1+n)t m {k=l;p}p ~> Walk n (1+m)t {k=l;p}p
 deriving syntax (w) Nat(Origin, North) Tick(SE) Pair(Pair)

-- list of walks ending in the same stratum
data Walks :: Nat ~> *1 where
  Heart :: Walks n
  Wrap :: Walk n m p ~> Walks n ~> Walks n
 deriving syntax (ws) List(Heart, Wrap)

-- Qualifiers are
--   * 0-dimensional: 42, Int, *, ...
--   * 1-dimensional: PI a:Int.Int
--   * 2-dimensional: \, dependent product: {a:A, b:B(a)}
--   * etc.
--
-- they are parametrized by walks
-- TODO:
--   * Type applications
--   * Sigma types

data Qual :: Walk n m p ~> Walk (1+n)t m' p' ~> *  where
  Star :: Qual 2w 3w
  Up :: Qual (2+n)w (3+n)w -> Qual (3+n)w (4+n)w
  Type :: Qual 1w 2w
  Term :: Qual 0w 1w
  Ext :: Qual p {up p} -> Qual r s -> Qual (p, r)w s
  Lam :: Qual p {up p} -> Qual (p`1)w {up (p`1)w}
 deriving syntax (ty) Nat(Star, Up) Tick(Lam) Pair(Ext)

-- tau: calculate classifier
up :: Walk n m p ~> Walk (1+n)t m' p'
{up (c, h)w} = {up h}
{up ((c, h)w`1)w} = h
{up (p`2)w} = (p`1)w
{up (1+n)w} = (2+n)w
{up 0w} = 1w

tau :: Qual a ta -> Qual ta {up ta}
tau (c, h)ty = tau h
tau ((c, h)ty`1)ty = h
tau (p`2)ty = (p`1)ty
tau (1+n)ty = (2+n)ty
tau 0ty = 1ty
tau Type = Star
tau Term = Type

-- extract payload from lambda
charge :: Walk n m {k=l;p}p ~> Walk k l p
{charge (c, t)w} = c
{charge (p`1)w} = {charge p}

uncharge :: Qual p q -> Qual {charge p} {up {charge p}}
uncharge (c, _)ty = c
uncharge (p`1)ty = uncharge p

-- calculate heart
heart :: Walks n ~> Walk n 0t None
{heart [h]ws} = h
{heart [a, b; r]ws} = {heart [b; r]ws}

-- contexts accumulate qualifiers (possibly around a heart)

kind Fixture = Floating | Anchored

data Context :: Fixture ~> Walks n ~> * where
  Empty :: Context Floating []ws
  Heart :: Qual n (1+n)w -> Context Anchored [n]ws
  Qualify :: Qual (v`1)w {up (v`1)w} -> Context f ws -> Context f [(v`1)w; ws]ws
  Appl' :: Equal {charge f} b
           => Qual a b
           -> Context Anchored [f; r]ws
           -> Context Anchored r
 deriving syntax (c) List(Empty, Qualify) Pair(Appl')

-- runtime values are represented by expressions

{-
data Expr :: Walks n ~> * where
  Lit :: Qual a b -> Expr [a]ws  -- e.g. 42::Int
  Lambda :: Context Anchored [a, b; r]ws -> Expr [a, b; r]ws -- e.g. \a:Int.42
  Appl :: Equal {charge f} {up a} => Expr [a]ws -> Expr [f; r]ws -> Expr r
-}

-- Tests

-- TODO ##test "exclude Term categorizer"
kt0 = (Term, Star)ty

-- regular lambda2 : \x:Int.42
lambda2Int = ((Type, Star)ty`2)ty
kt1 = (Term, [lambda2Int; Heart Term]c)c

-- regular PI1 : pi (x:Int).Int
pi1Int = ((Type, Star)ty`1)ty
kt2 = (Term, [pi1Int; Heart Type]c)c

-- type-level lambda2 : /\x:*:Int
lambda2star = ((0ty, 1ty)ty`2)ty
kt3 = (Type, [lambda2star; Heart Type]c)c

-- mixed form: \f:Int->Int.f 42
lambda2Int_Int = ((pi1Int, 0ty)ty`2)ty
kt4 = (lambda2Int, [lambda2Int_Int; Heart Term]c)c

-- 2 args: \f i.f i
kt5 = (Term, lambda2Int, [lambda2Int_Int, lambda2Int; Heart Term]c)c

