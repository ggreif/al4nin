import "LangPrelude.prg"

-- for now this is untyped,
-- I just want to demonstrate the 2-step
-- approach

kind Term = Terminator | Regular
kind Init = InitBlock | SuccBlock

kind Origin = Const | Defined Tag

data Use :: Origin ~> * where
   Const :: Int -> Use Const
   Use :: Label t -> Use (Defined t)

---------------
-- primitives
-- these can be parsed from a text file for example
--
data Prim :: Term ~> Init ~> Uses ~> * where
  Add :: Use cn -> Use cn' -> Prim Regular b {trackUses2 cn cn' []u}
  Ret :: Use cn -> Prim Terminator b {trackUses1 cn []u}

kind Lab = Named Tag | Anon

data Ref :: Lab ~> * where
  Tag :: Label t -> Ref (Named t)
  Anon :: Ref Anon

data Block :: Row Lab Term ~> * where
  Fin :: Block {}r
  BCons :: Ref l -> Prim t i u -> Block r -> Block {l=t; r}r
 deriving Record(b)

test1 = {Anon=Ret $ Const 5}b
test2 = {Tag `a=Add (Const 40) (Const 2), Anon=Ret $ Use `a}b

---------------
-- instructions
-- these actually track the defs and uses in the type system

-- uses
-- since we are untyped for now
-- we have a list of them
data Uses :: *1 where
  NoUses :: Uses
  AddUse :: Tag ~> Uses ~> Uses
 deriving List(u)

trackUses1 :: Origin ~> Uses ~> Uses
{trackUses1 Const us} = us
{trackUses1 (Defined t) us} = [t; us]u

trackUses2 :: Origin ~> Origin ~> Uses ~> Uses 
{trackUses2 Const Const us} = us
{trackUses2 Const (Defined t) us} = [t; us]u
{trackUses2 (Defined t) Const us} = [t; us]u
{trackUses2 (Defined t) (Defined t') us} = [t, t'; us]u

appendUses :: Uses ~> Uses ~> Uses
{appendUses []u us} = us
{appendUses [t; r]u us} = [t; {appendUses r us}]u


-- defs
-- since we are	untyped	for now
-- we have a list of them
data Defs :: *1 where
  NoDefs :: Defs
  AddDef :: Tag ~> Defs ~> Defs
 deriving List(d)

prop FreeDef :: Tag ~> Defs ~> * where
  Trivially :: FreeDef t []d
  More :: DiffLabel t t' -> FreeDef t r -> FreeDef t [t'; r]d
 deriving List(f)

{- NONSENSE!
checkDef :: FreeDef t u -> Label t -> Prim Regular i us -> Maybe (FreeDef t {appendUses us u})
checkDef f l (Add (Const _) (Const _)) = Just f
-}

data Props :: *1 where
  A :: Defs ~> Uses ~> Props

-- exec should only apply when the return type of the primitive is void!
data Instr :: Props ~> Props ~> * where
  Def :: FreeDef t d => Label t -> Prim Regular i us -> Instr (A d {appendUses us u}) (A [t; d]d u)
  Exec :: Prim Regular i us -> Instr (A d {appendUses us u}) (A d u)
  Term :: Prim Terminator i us -> Instr (A d {appendUses us u}) (A d u)

test3 = Term $ Ret (Const 42)
test4 = Def `a $ Add (Const 40) (Const 2)
test5 = Def `a $ Add (Const 40) (Use `b)
test6 = Def `a $ Add (Use `b) (Use `c)

data Thrist :: forall (l :: *1) . (l ~> l ~> *)  ~> l ~> l ~> * where
  Nil :: Thrist k a a
  Cons :: k a b -> Thrist k b c -> Thrist k a c
 deriving List(l)


{- NOT YET!
--##test "double def not permitted"
test7 :: Instr (A [`b]d []u) (A [`a, `b]d []u)
test7 = Def `a $ Add (Const 40) (Const 2)
-}

test8 = [test5, test3]l

data UseEvidence :: Uses ~> * where
  NoUses :: UseEvidence []u
  AddUse :: Label l -> UseEvidence r -> UseEvidence [l; r]u
 deriving List(ue)

buildBasicBlock2 :: Label t ->
                    Prim Regular i us ->
                    Prim Terminator i us' ->
                    Maybe (Thrist Instr (A []d {appendUses us {appendUses us' []u}}) (A [t]d []u))
buildBasicBlock2 l (a@Add _ _) (r@Ret _) = Just [Def l a, Term r]l
buildBasicBlock2 _ _ _ = Nothing

test9 = buildBasicBlock2 `t (Add (Const 40) (Const 2)) (Ret $ Const 2)
test10 = buildBasicBlock2 `t (Add (Const 40) (Const 2)) (Ret $ Use `t)
test11 = buildBasicBlock2 `t (Add (Const 40) (Use `a)) (Ret $ Use `t)
test12 = buildBasicBlock2 `t (Add (Use `c) (Use `a)) (Ret $ Use `t)

defsOnly :: Row Lab Term ~> Defs
{defsOnly {}r} = []d
{defsOnly {Anon=t; r}r} = {defsOnly r}
{defsOnly {(Named n)=t; r}r} = [n; {defsOnly r}]d


buildBasicBlock :: Block r -> exists u . Maybe (Thrist Instr (A []d u) (A {defsOnly r} []u), UseEvidence u)
buildBasicBlock {}b = Ex Nothing
buildBasicBlock {Anon=(r@Ret (Const _))}b = Ex (Just ([Term r]l, NoUses))
buildBasicBlock {Anon=(r@Ret (Use l))}b = Ex (Just ([Term r]l, [l]ue))


test13 = buildBasicBlock {Anon=(Ret (Use `a))}b
