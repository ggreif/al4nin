import "LangPrelude.prg"

-- Applicative functors

data Applicative :: (* ~> * ~> *) ~> * ~> * where
  Fun :: f a b -> Applicative f (f a b)
  Val :: a -> Applicative f a
  App :: Applicative f (f a b) -> Applicative f a -> Applicative f b


data Thrist :: forall (l :: *1) . (l ~> l ~> *)  ~> l ~> l ~> * where
  Nil :: Thrist k a a
  Cons :: k a b -> Thrist k b c -> Thrist k a c
 deriving List(l)

t0 = App (App (Fun (+)) (Val 40)) (Val 2)
t1 = App (Fun [chr]l)

data Arith :: * ~> * ~> * where
  Plus :: Arith Int (Arith Int Int)
  Minus :: Arith Int (Arith Int Int)
  Times :: Arith Int (Arith Int Int)
  Div :: Arith Int (Arith Int Int)
  Mod :: Arith Int (Arith Int Int)

t2 = App (App (Fun Plus) (Val 40)) (Val 2)

concType :: * ~> *
{concType (Arith a b)} = {concType a} -> {concType b}
{concType Int} = Int

concretize :: Applicative Arith a -> Applicative (->) {concType a}
concretize (Fun Plus) = Fun (+)
--concretize (Val a) = Val a -- need representation types here
concretize (App f a) = App (concretize f) (concretize a)

{-
I want something like

[map, [plus, 1]l, [from, 1, 5]l ]l

-}
