{ Sequence transforms }
{ do on popping
MIX (Seq (Tag q a) (Tag q b)) done => MIX (Tag q (Seq a b)) done;
MIX (Seq (Seq a b) c) done => MIX (Seq a (Seq b c)) done;
}

{ Tag transforms }
{ do on pushing too, below }
MIX (Tag q (Tag q x)) done => MIX (Tag q x) done;


MIX (Tag Maj (Tag Emph d)) done => MIX (Tag Emph (Tag Maj d)) done;
MIX (Tag Maj (Tag Bold d)) done => MIX (Tag Bold (Tag Maj d)) done;
MIX (Tag Emph (Tag Bold d)) done => MIX (Tag Bold (Tag Emph d)) done;


{ Argument evaluation }
MIX (Seq a b) done => MIX a (Push done b);

{ Result popping }
 {MIX (Tag q (Seq a b)) done => MIX (Seq a b) (Gat q done);NEEDED??}
 {MIX (Tag q (Tag p (Seq a b))) done => MIX (Seq a b) (Gat p (Gat q done));NEEDED??}

MIX (Seq a b) done => MIX b (Qes a done); {+++}

MIX (Tag q d) (Gat q done) => MIX d (Gat q done);

{ If something smaller on results, swap, maybe we have to undo too # }
MIX (Tag Emph d) (Gat Maj done) => MIX (Tag Maj d) (Gat Emph done);
MIX (Tag Bold d) (Gat Emph done) => MIX (Tag Emph d) (Gat Bold done);
MIX (Tag Bold d) (Gat Maj done) => MIX (Tag Maj d) (Gat Bold done);

MIX (Tag q d) done => MIX d (Gat q done);

{ Reversal }
MIX A (Push done b) => MIX b (Qes A done); {+++}
MIX B (Push done b) => MIX b (Qes B done);
MIX A (Qes a b) => XIM (Seq a A) b; {+++}
MIX B (Qes a b) => XIM (Seq a B) b;
MIX A (Gat a b) => XIM (Tag a A) b; {+++}
MIX B (Gat a b) => XIM (Tag a B) b;


{ Reconstruction }

XIM (Tag q a) (Push done (Tag q b)) => MIX (Tag q (Seq a b)) done;
XIM (Seq a b) (Push done c) => MIX (Seq a (Seq b c)) done;
XIM d (Push done b) => MIX b (Qes d done);

XIM d (Qes a b) => XIM (Seq a d) b; {+++}
XIM d (Gat q b) => XIM (Tag q d) b;
XIM d ROOT => d;

{ Evaluation context }
SNF x => MIX x ROOT;

{ No more rules }
.


{ SNF (Seq (Tag Bold (Tag Bold (Seq (Seq A A) (Seq A A)))) (Tag Emph (Tag Maj (Tag Maj (Tag Bold B))))) }

{ Incorrect : ((Seq ((Tag Bold) ((Seq A) ((Seq A) ((Seq A) A))))) ((Tag Emph) ((Tag Bold) ((Tag Maj) B)))) }