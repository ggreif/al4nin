-- Discriminated sums as injections

-- TODO:
--  * make 'constr' total by tracking the tags of injections in 'Sum' as a type index
--  * implement recursive/parameterized sums
--  * catas, anas etc. (E. Meijer et al.)

injtype :: Tag ~> TypeList ~> * ~> *
{injtype `Le []tl a} = Int -> a
{injtype `Mi []tl a} = [Char] -> a
{injtype `Ri []tl a} = Bool -> a -> a
{injtype `Ni [b]tl a} = a
{injtype `Co [b]tl a} = b -> a -> a

sumtype :: Tag ~> *
{sumtype `Test} = Test
{sumtype `List} = List a
--{sumtype  } =

data TypeList :: *1 where
  FNil :: TypeList
  FCons :: * ~> TypeList ~> TypeList
 deriving List(tl)

data Free :: TypeList ~> * where
  Zero :: Free []tl
  More :: Free l -> Free [a; l]tl
 deriving Nat(f)

data Injections :: TypeList ~> Tag ~> * ~> * where
  None :: Injections tl t f
  Inj :: (Free tl, Label cn) -> {injtype cn tl f} -> Injections tl t f -> Injections tl t f
 deriving Record(is)

data Sum :: TypeList ~> Tag ~> * ~> * where
  Constrs :: (Free tl, Label sn) -> Injections tl sn {sumtype sn} -> Sum tl sn {sumtype sn}
 deriving Pair(sum)

constr :: Sum tl sum {sumtype sum} -> Label constr -> {injtype constr tl {sumtype sum}}
constr (p@(free, l), {(_, c')=inj; cs}is)sum c = case sameLabel c c' of
                                                 L Eq -> inj
                                                 _ -> constr (p, cs)sum c


data Test :: * where
  Le :: Int -> Test
  Mi :: [Char] -> Test
  Ri :: Bool -> Test -> Test
 deriving syntax(test) Item(Mi)


t0 = ((0f, `Test), {(0f,`Le)=Le,(0f,`Mi)=Mi,(0f,`Ri)=Ri}is)sum
t1 = constr t0 `Mi "Hello World!"

data List :: * ~> * where
  Ni :: List a
  Co :: a -> List a -> List a
 deriving List(li)

t2 = ((1f, `List), {(1f,`Ni)=Ni,(1f,`Co)=Co}is)sum


-- this allows us to construct homogenous lists
--t2good :: List Int
t2good = let (co, ni) = (constr t2 `Co, constr t2 `Ni) in co 25 $ co 42 ni


-- and, GASP!, heterogenous ones too:
--##test "do not allow heterogenous lists"
t2bad :: List Int
t2bad = constr t2 `Co 's' $ constr t2 `Co 42 (constr t2 `Ni)

t2badHead :: Int
t2badHead = case t2bad of {Co h _ -> h}

--##test "crash!"
t2badExpose = show (case t2badHead of {11->11; other->other+0})


