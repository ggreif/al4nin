import "LangPrelude.prg"

-- values, they are used for building verbose contexts

data Value :: * where
  Ref :: Label n -> Value
  Sole :: Value
  App :: Value -> Value -> Value
  Typed :: Value -> Value -> Value
 deriving syntax(va) LeftList(Sole, App) Pair(Typed)

data Raw :: Tag ~> * ~> * ~> * where
  Def :: Value -> Raw t Value Value
  Annotated :: Value -> Value -> Raw t Value Value
 deriving syntax(ra) Pair(Annotated)

-- well-formedness: check that names are always defined at the point of reference

data WellFormed :: Tag ~> Sofar Tag ~> Sofar Tag ~> * where
  DefFormed :: Raw n Value Value -> NamesSofar [r; n]sf -> WellFormed n r [r; n]sf

data Sofar :: *1 ~> *1 where
  No :: Sofar t
  Join :: Sofar t ~> t ~> Sofar t
 deriving LeftList(sf)


data NamesSofar :: Sofar Tag ~> * where
  NoNames :: NamesSofar []sf
  NamesSofar :: NamesSofar sf -> Label t -> NamesSofar [sf; t]sf
 deriving LeftList(nsf)

data Includes :: Sofar Tag ~> Tag ~> * where
  Roo :: Equal f t -> Includes [r; f]sf t
  Ind :: Includes r t -> Includes [r; f]sf t
 deriving syntax(i) Tick(Ind)

-- does t appear in bf?
checkInside :: Label t -> NamesSofar bf -> Maybe (Includes bf t)
checkInside _ []nsf = Nothing
checkInside l [r; l']nsf = case sameLabel l l' of
                           L Eq -> Just (Roo Eq)
                           _ -> case checkInside l r of
                                      Just ev -> Just (Ind ev)
                                      Nothing -> Nothing

-- are all free vars bound in bf?
verifyFree :: NamesSofar bf -> Value -> exists t . Maybe (Label t, Includes bf t)
verifyFree bf (Ref l) = case checkInside l bf of
                        Nothing -> Ex Nothing
                        Just ev -> Ex (Just (l, ev))
verifyFree bf Sole = Ex Nothing
verifyFree bf (App f v) = verifyFree bf v

checkWellformedness :: NamesSofar bf
                    -> VerboseContext Raw Value Value
                    -> (VerboseContext WellFormed bf sf, NamesSofar sf)
checkWellformedness bf {}ve = cast ({}ve, bf)
                                where cast :: (VerboseContext WellFormed bf bf, NamesSofar bf)
                                           -> (VerboseContext WellFormed bf sf, NamesSofar sf)
                                      cast = unsafeCast
checkWellformedness bf {l=(_, v)ra; r}ve = ({l=DefFormed (Def v) new; follows}ve, newest)
                                             where new = [bf; l]nsf
                                                   (follows, newest) = checkWellformedness new r


data WellLevelled :: Nat ~> * where
  At :: Nat' l -> WellLevelled l

-- representation of contexts with names
data VerboseContext :: (Tag ~> a ~> a ~> *) ~> a ~> a ~> * where
  E :: VerboseContext k a a
  Q :: Label n -> k n a b -> VerboseContext k b c -> VerboseContext k a c
 deriving syntax(ve) Record(E, Q)

-- Examples of VerboseContext


-- h :: (Foo :: * ~> *) Int
h_is_Int = { `Int=(Ref `Type, Ref `Star)ra
           , `h=([]va, [(Ref `Foo, [Ref `Karr, Ref `Star, Ref `Star]va)va, Ref `Int]va)ra
           }ve

(well_h_is_Int, defs_h_is_Int@[`Int, `h]nsf) = checkWellformedness []nsf h_is_Int
