import "LangPrelude.prg"

data Payload :: *1 where
  None :: Payload
  Charge :: Nat ~> Nat ~> Payload

--                  v-- pre-* distance
--           v-- stratum
data Walk :: Nat ~> Nat ~> Payload ~> *1 where
  Origin :: Walk 0t 0t None
  Up :: Walk n 0t None ~> Walk (1+n)t 0t None
  Pair :: Walk k l None ~> Walk n m None ~> Walk n m (Charge k l)
  SE :: Walk (1+n)t m (Charge k l) ~> Walk n (1+m)t (Charge k l)
 deriving syntax (w) Nat(Origin, Up) Tick(SE) Pair(Pair)


data Type :: Walk n m p ~> *  where
  Star :: Type 2w
  Up :: Type (2+n)w -> Type(3+n)w
  Type :: Type 1w
  Term :: Type 0w
  Ext :: Type (1+n)w -> Type r -> Type ((1+n)w, r)w
  Lam :: Type p -> Type (p`1)w
 deriving syntax (ty) Nat(Star, Up) Tick(Lam) Pair(Ext)



-- Tests

##test "exclude Term categorizer"
  t0 = (Term, Star)ty

-- strange Term (pi (x:Int).42)
-- whose tau is lambda0 (x:Int).Int
-- by definition same as Int
-- should we disallow it?
pi1_42 = ((Type, Type)ty`1)ty

-- regular lambda2 : \x:Int.42
lambda2Int = ((Type, Star)ty`2)ty

-- regular PI1 : pi (x:Int).Int
pi1Int = ((Type, Star)ty`1)ty

-- type lambda2 : /\x:*:Int
lambda2star = ((0ty, 1ty)ty`2)ty

