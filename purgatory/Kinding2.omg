{-
 * Copyright (c) 2010 Gabor Greif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 -}

-- Implement the PTS-like plane
-- of PIs and lambdas (\ and /\), etc.
-- Please refer to
--  http://www.cedar-forest.org/forest/papers/journals-publications/jfp6-2.ps
-- (esp. p. 4, item 4. "Higher degrees").
--
-- There are still many limitations, but I think
-- the major obstacles are solved, contexts are
-- easy to add, moreover categorizers must admit
-- dependent types.

import "LangPrelude.prg"

-- walks in the lambda plane

data Payload :: *1 where
  None :: Payload
  Charge :: Nat ~> Nat ~> Payload ~> Payload
 deriving Record(p)

--                  v-- dimensionality
--           v-- stratum
data Walk :: Nat ~> Nat ~> Payload ~> *1 where
  Origin :: Walk 0t 0t None
  North :: Walk n 0t None ~> Walk (1+n)t 0t None
  Pair :: Walk k l p ~> Walk n m None ~> Walk n m {k=l;p}p
  SE :: Walk (1+n)t m {k=l;p}p ~> Walk n (1+m)t {k=l;p}p
 deriving syntax (w) Nat(Origin, North) Tick(SE) Pair(Pair)

-- Qualifiers are
--   * 0-dimensional: 42, Int, *, ...
--   * 1-dimensional: PI a:Int.Int
--   * 2-dimensional: \, dependent product: {a:A, b:B(a)}
--   * etc.
--
-- they are parametrized by walks
-- TODO:
--   * Type applications
--   * Sigma types

data Qual :: Walk n m p ~> Walk (1+n)t m' p' ~> *  where
  Star :: Qual 2w 3w
  Up :: Qual (2+n)w (3+n)w -> Qual (3+n)w (4+n)w
  Type :: Qual 1w 2w
  Term :: Qual 0w 1w
  Ext :: Qual p {up p} -> Qual r s -> Qual (p, r)w s
  Lam :: Qual p {up p} -> Qual (p`1)w {up (p`1)w}
 deriving syntax (ty) Nat(Star, Up) Tick(Lam) Pair(Ext)

-- tau: calculate classifier
up :: Walk n m p ~> Walk (1+n)t m' p'
{up (c, h)w} = {up h}
{up ((c, h)w`1)w} = h
{up (p`2)w} = (p`1)w
{up (1+n)w} = (2+n)w
{up 0w} = 1w

tau :: Qual a ta -> Qual ta {up ta}
tau (c, h)ty = tau h
tau ((c, h)ty`1)ty = h
tau (p`2)ty = (p`1)ty
tau (1+n)ty = (2+n)ty
tau 0ty = 1ty
tau Type = Star
tau Term = Type

-- extract payload from lambda
charge :: Walk n m {k=l;p}p ~> Walk k l p
{charge (c, t)w} = c
{charge (p`1)w} = {charge p}

uncharge :: Qual p q -> Qual {charge p} {up {charge p}}
uncharge (c, _)ty = c
uncharge (p`1)ty = uncharge p

-- calculate heart
south :: Walk (1+n)t 0t None ~> Walk n 0t None
{south (1+n)w} = n

heart :: Walk n m {k=l;p}p ~> Walk n 0t None
{heart (p`1)w} = {south {heart p}}
{heart (c, h)w} = h

-- runtime values are represented by expressions

data Expr :: Walk n m p ~> * where
  Lit :: Qual a b -> Expr a  -- e.g. 42::Int
  Lambda :: Qual (p`1)w {up (p`1)w} -> Expr {heart (p`1)w} -> Expr (p`1)w -- e.g. \a:Int.42
  Appl :: Expr f -> Expr {south {charge f}} -> Expr {heart f}


-- Tests

-- TODO ##test "exclude Term categorizer"
t0 = (Term, Star)ty

-- regular lambda2 : \x:Int.42
lambda2Int = ((Type, Star)ty`2)ty
t1 = Appl (Lambda lambda2Int (Lit Term)) (Lit Term)

-- regular PI1 : pi (x:Int).Int
pi1Int = ((Type, Star)ty`1)ty
t2 = Appl (Lambda pi1Int (Lit Type)) (Lit Term)

-- type-level lambda2 : /\x:*:Int
lambda2star = ((0ty, 1ty)ty`2)ty
t3 = Appl (Lambda lambda2star (Lit Type)) (Lit Type)

-- mixed form: \f:Int->Int.f 42
lambda2Int_Int = ((pi1Int, 0ty)ty`2)ty

