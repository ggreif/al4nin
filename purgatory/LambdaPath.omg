-- make lambda terms indexed by a custom kind
-- and allow paths poke into its innards

data Dir :: *1 where
  Down :: Dir ~> Dir
  Left :: Dir ~> Dir
  Right :: Dir ~> Dir
  

data LT :: Dir ~> *1 where
  AbsLT :: LT (Down a) ~> LT a
  AppLT :: LT (Left a) ~> LT (Right a) ~> LT a


-- Key insight (for now) is that the semantics
-- of lambdas and applications occurs _in place_
-- whereas references possess semantics from
-- another place, so each term must have two indices:
--  o where it is located
--  o where the semantics is

-- Terms 

data Term :: (LT d) ~> * where
  Lam :: Term a -> Term (AbsLT a)
  App :: Term a -> Term b -> Term (AppLT a b)
  -- constituent references
  Above :: Term a
  AboveL :: Term a
  AboveR :: Term a
  Up :: Term a -> Term (AbsLT a)
  UpL :: Term b -> Term (AppLT a b)
  UpR :: Term a -> Term (AppLT a b)


-- Example: \x f a = f a
e1 = Lam (Lam (App (Up $ Up AboveR) (Up AboveL)))

-- this system still admits flawed references:
e1' = Lam (Lam (App (Up $ UpL AboveR) (Up AboveL)))
----------------------------^----------------------


