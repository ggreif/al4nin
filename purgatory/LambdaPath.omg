-- make lambda terms indexed by a custom kind
-- and allow paths poke into its innards

data Dir :: *1 where
  Down :: Dir ~> Dir
  Left :: Dir ~> Dir
  Right :: Dir ~> Dir
  

data LT :: Dir ~> *1 where
  AbsLT :: LT (Down a) ~> LT a
  AppLT :: LT (Left a) ~> LT (Right a) ~> LT a


-- Key insight (for now) is that the semantics
-- of lambdas and applications occurs _in place_
-- whereas references possess semantics from
-- another place, so each term must have two indices:
--  o where it is located
--  o where the semantics is

-- determining path from structure
{-
path :: LT p ~> p
{path (AbsLT p)} = Down p
{path ()} =
-}

-- Terms 

data Term :: Dir ~> (LT d) ~> * where
  Lam :: Term (Down p) a -> Term p (AbsLT a)
  App :: Term (Left p) a -> Term (Right p) b -> Term p (AppLT a b)
  -- constituent references
  Here :: Term {-path loc-}p loc
  Up :: Term (Down p) loc -> Term p loc
  UpL :: Term (Right p) loc -> Term p loc
  UpR :: Term (Left p) loc -> Term p loc


-- Example: \x f a = f a
--e1 :: Term root (AbsLT (AbsLT (AppLT a b)))
e1 = Lam (Lam (App (Up $ Up $ UpR Here) (Up $ UpL Here)))

-- this system still admits flawed references:
--e1' = Lam (Lam (App (Up $ UpL AboveR) (Up AboveL)))
----------------------------^----------------------


