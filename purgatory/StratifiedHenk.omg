-- -*-Haskell-*-

{-
 * Copyright (c) 2006, 2007 Gabor Greif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 -}

-- Usage:
--
--  Set up the environment
--     setenv LD_LIBRARY_PATH /opt/exp/gnu/lib:$LD_LIBRARY_PATH
--     setenv PATH /home/ggreif/%NoBackup%/Omega1.4:$PATH
--
--  Start the omega interpreter by typing
--     omega StratifiedHenk.omg
--  and run your commands on the prompt
--

import "LangPrelude.prg" 
  (head,tail,lookup,member,fst,snd,map,Monad,maybeM,id,ioM,Row,HasType,RCons,RNil,Eq,Equal)

-- \(x:T).x : Pi (x:T) T

-- cit: Kamareddine jfp6
-- Higher Degrees:
-- tau(Gam, lam[i+1]x:A.B) === lam[i]x:A.tau(Gam\x:A, B) forall i of N
--  where lam[0]x:A.B === B
-- lam[1] == Pi, lam[2] == lambda
-- Specialize (i=1):
--  tau(Gam, lambda x:A.B) === Pi x:A.tau(Gam\x:A, B)
-- Specialize (A=int, B=42):
--  tau(Gam, lambda x:Int.42) === Pi x:Int.tau(Gam\x:Int, 42)
--  with tau(Gam, 42) === Int
--  gets: tau(Gam, lambda x:Int.42) === Pi x:Int.Int  (aka. Int->Int)

-- Specialize (i=0, A=Int, B=Int):
-- tau(Gam, Pi x:Int.Int) === lam[0]x:Int.tau(Gam\x:Int, Int)
-- with tau(Gam, Int) === *0
-- tau(Gam, Pi x:Int.Int) === lam[0]x:Int.*0
-- with lam[0]x:Int.*0 === *0
-- tau(Gam, Pi x:Int.Int) === *0

kind Stratum :: *1 where
  Ground :: Stratum
  Up :: Stratum ~> Stratum
 deriving Nat(s)

-- --------- From       To
data Henk :: Stratum ~> Stratum ~> *0 where
--  Lit :: a -> Henk Ground Ground
  Lit :: Henk Ground Ground
  Bind :: Label l -> Henk Ground strat -> Henk from to -> Henk strat to
  Func :: (a->b) -> Henk (Up Ground) Ground
--  Ref :: Label l -> Henk Ground strat
  Type :: Henk Ground (Up Ground)
  Star :: Henk Ground (Up (Up g))
  -- Application
--  App :: Henk (Up s) s -> Henk st s -> Henk st s
  App :: Henk (Up s) u -> Henk st s -> Henk st u
--  Dep :: Henk (Up s) (Up s) -> Henk st s -> Henk st (Up s)


--a :: Henk Ground Ground
--a = Ref `a

tau :: Henk strat to -> Henk strat (Up to)
tau (Bind l q r) = Bind l q (lazy tau r)
tau (a@Lit) = tau (Bind `ignore a a)
--tau (a@Lit) = Type
tau (t@Type) = Star
tau (s@Star) = Star

--getType :: Henk strat to -> Henk strat (Up to)
--getType (b@Bind l q r) = tau b

eval :: Henk st s -> Henk st s
--evalLam (Bind l q r) (a@Lit) = r
