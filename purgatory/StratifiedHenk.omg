-- -*-Haskell-*-

{-
 * Copyright (c) 2006 Gabor Greif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 -}

-- Usage:
--
--  Set up the environment
--     setenv LD_LIBRARY_PATH /opt/exp/gnu/lib:$LD_LIBRARY_PATH
--     setenv PATH /home/ggreif/%NoBackup%/Omega1.2.1:$PATH
--
--  Start the omega interpreter by typing
--     omega StatifiedHenk.omg
--  and run your commands on the prompt
--

import "/Users/ggreif/Desktop/Omega1.2.1a/LangPrelude.prg" 
  (head,tail,lookup,member,fst,snd,map,Monad,maybeM,id,ioM,Row,HasType,RCons,RNil)

-- \(x:T).x : Pi (x:T) T

kind Typable = Ground *0 | Elevate Typable

strat :: Typable ~> Nat
{strat (Ground a)} = Z
{strat (Elevate a)} = S {strat a}

binder :: Nat ~> Nat ~> Nat ~> Nat
{binder (S Z) Z Z} = #2 -- \a:T.c
{binder (S Z) Z #2} = #2 -- \a:T.\...
{binder Z Z Z} = #1 -- Pi
{binder Z Z #1} = #1 -- Pi.Pi
{binder (S a) (S b) c} = {binder a b c}
{-
binder :: Typable ~> Typable ~> Nat ~> Nat
{binder (Elevate (Ground a)) (Ground b) Z} = #2 -- \a:T.c
{binder (Elevate (Ground a)) (Ground b) #2} = #2 -- \a:T.\...
{binder (Elevate (Elevate (Ground a))) (Elevate (Ground b)) Z} = #2 -- \a:*.c
{binder (Elevate (Elevate (Ground a))) (Elevate (Ground b)) #2} = #2 -- \a:*.\...
{binder (Elevate (Ground a)) (Elevate (Ground b)) Z} = #1 -- Pi
{binder (Elevate (Ground a)) (Elevate (Ground b)) #1} = #1 -- Pi.Pi
{binder (Elevate (Elevate (Ground a))) (Elevate (Elevate (Ground b))) Z} = #1 -- Pi:*
{binder (Elevate (Elevate (Ground a))) (Elevate (Elevate (Ground b))) #1} = #1 -- Pi:*.Pi
-}

bound  :: Typable ~> Typable ~> Nat ~> Nat ~> Nat
{bound (Ground a) (Ground b) #2 Z} = Z
{bound (Elevate (Ground a)) (Ground b) #1 Z} = Z

data Henk :: Typable ~> Nat ~> * where
  Star :: Henk (Elevate (Elevate (Ground a))) Z
  Lam :: Symbol -> Henk (Elevate stratum) Z -> Henk stratum' b -> Henk stratum {binder {strat (Elevate stratum)} {strat stratum'} b}
  App :: Henk stratum b -> Henk stratum' b' -> Henk stratum {bound stratum stratum' b b'}
  Var :: Symbol -> Henk stratum Z
  Type :: String -> Henk (Elevate (Ground a)) Z
  Const :: a -> Henk (Ground a) Z

a = fresh 'a'
l = Lam a Star (Var a)

int = Type "Int"

pi1 = Lam a Star Star
pi0 = Lam a int int


freshVar c = Var (fresh c)


al = fresh 'a'
ll = Lam al Star l
all = fresh 'a'
lll :: Henk (Ground a) #2
lll = Lam all int (Const 42)

alll = fresh 'a'
llll :: Henk (Ground a) #2
--vlll :: Henk (Ground Int) #0
vlll = Var all
llll = Lam alll int (vlll::Henk (Ground Int) #0)

b = fresh 'b'

app = App l (Var b)

l1 = Lam b int (Const 42)
a1 = App l1  (Var $ fresh 'c')


eval :: Henk stratum b -> [(Symbol, Henk stratum b)] -> Henk stratum b
eval Star _ = Star
eval (var@Var name) ((s, v):svs) = if symbolEq name s then v else eval var svs
eval (l@Lam s t e) bs = l
--eval (App (Lam s t e) h) bs = eval e ((s, h):bs)
eval (c@Const _) _ = c

lessen :: Nat ~> Nat
{lessen #2} = #1
{lessen #1} = #0
{lessen #0} = #0

tau :: Henk stratum b -> Henk (Elevate stratum) {lessen b}
tau (Type _) = Star
tau (Const _) = int
tau (l@Lam s t e) = case l of Lam a b c -> Lam s t t
--tau (App f e) = App (tau f) e


{-
data Henk' :: (Nat ~> Nat ~> Nat ~> *) ~> Nat ~> Nat ~> * where
  Star :: Henk' appl #2 Z
  Rectangle :: Henk' appl #3 Z
  Var :: String -> Henk' appl stratum Z
  App :: Henk' appl stratum b -> Henk' appl s binding -> Henk' appl stratum Z
  Lam 
-}
{-
data Henk' appl stratum binding
 = Star where stratum = #2, binding = Z
 | Rectangle where stratum = #3, binding = Z
 | Lozenge where stratum = #3, binding = Z
 | Var String where binding = Z
 | exists s b . App (Henk' appl stratum b) (Henk' appl s binding) where appl stratum b s, binding = Z
 | Lam (Henk' appl stratum Z) (Henk' appl (S stratum) Z) (Henk' appl stratum Z) where binding = #2
 | exists s . Pi (Henk' appl s Z) (Henk' appl (S s) Z) (Henk' appl (S s) Z) where stratum = (S s), binding = #1
-}

{-
prop Applicable stratum binder stratum'
 = PiAppl where binder = #1, stratum = S stratum'
 | LamAppl where binder = #2, stratum = stratum'

--Henk :: Nat ~> Nat ~> *
type Henk = Henk' Applicable

--- Bug?
--- type Value = Henk #0 #0

type Value = Henk' Applicable #0 #0
type ValueLam = Henk' Applicable #0 #2
type Type = Henk' Applicable #1 #0
type TypeLam = Henk' Applicable #1 #2
type Kind = Henk' Applicable #2 #0
type KindPi = Henk' Applicable #2 #1
type KindLam = Henk' Applicable #2 #2

exp0 :: Value
exp0 = Var "b:Bool"

exp1 :: TypeLam
exp1 = Lam (Var "s") Star (Var "s")  -- lam s:*0 . s
exp1' :: Kind
exp1' = App exp2' Star
-- this should not typecheck:
-- exp1'' = App exp2' Rectangle

exp2 :: KindPi
exp2 = Pi (Var "_") Star Star        -- *0 ~> *0
exp2' :: KindLam
exp2' = Lam (Var "_") Rectangle Star -- LAM _:*1 . *0

-- todo:
--  - Item notation
--  - reduction rules
--  - type inference of lambda terms
--  - ANF conversion

-- type inference of lambda terms
down :: Nat ~> Nat
{down Z} = Z
{down (S b)} = b

tau :: Henk' appl n b -> Henk' appl (S n) {down b}
tau Star = Rectangle
--tau Rectangle = Lozenge
tau (Lam v domain result) = Pi (Var "_") domain (tau result)
tau (App (Lam _ _ expansion) _) = tau expansion
tau (App (Pi _ _ expansion) _) = tau expansion

--tt1 = tau exp1
--tt2 = tau (App exp2 exp1)
tt3 = tau (App exp2' Star)
 -}